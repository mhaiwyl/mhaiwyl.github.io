{"meta":{"title":"mhaiwyl","subtitle":"愿努力、奋斗、坚持能为你带来好运","description":"不甘现状，努力奋斗！","author":"Mh","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Mybatis的配置-Mh","slug":"Mybatis的配置","date":"2019-09-14T05:18:04.344Z","updated":"2019-09-23T08:04:44.280Z","comments":true,"path":"2019/09/14/Mybatis的配置/","link":"","permalink":"http://yoursite.com/2019/09/14/Mybatis的配置/","excerpt":"","text":"mybatis的配置创建好一个maven项目1、在pom.xml文件中配置所需要的版本号，jar包等。例： 4.0.0 &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;day01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、在resources文件下创建两个xxx.xml文件： （1）、xxx.xml开头文件是mybatis的config约束文件，里面主要配置数据库连接，指定映射配置文件的位置等；mybatis的主配置文件 例： &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置,映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/dao/IGameDao.xml&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt; （2）、配置与接口名称相同的xml文件，映射sql语句；里面的开头文件是为mapper的约束文件；映射配置文件 例： &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot;&gt; select * from game; &lt;/select&gt; 注意事项：1、上面创建的IGameDao.xml和IGameDao.java也可以叫做Mapper2、创建目录时，他和包结构不一样，包在创建时是三级结构，目录为一级目录。创建时需要一个一个按层创建3、mybatis的映射配置文件位置必须和dao接口的包结构相同4、映射配置文件的Mapper标签namespace属性的取值必须是dao接口的全限定类名5、映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名。上面几点如都配置正确的话，就无需编写dao层的实现类 测试类配置：大致为6步 //1、读取配置文件 InputStream in = Resources.getResourceAsStream(“SqlMapConfig.xml”); //2、创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3、使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4、使用SeqSession创建Dao接口的代理对象 IGameDao iGameDao = session.getMapper(IGameDao.class); //5、使用代理对象执行方法 /* 新增一条数据 */ Game g = new Game(); g.setGname(“手游吃鸡”); g.setName(“mh”); g.setPassword(“123”); String t = “2019-09-22”; SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”); g.setBirthday(sdf.parse(t)); iGameDao.saveGame(g); //提交事务 session.commit(); /* 修改用户 */ Game g1 = iGameDao.findById(5); g1.setGname(&quot;shaha&quot;); iGameDao.update(g1); session.commit(); /* 根据ID删除数据 */ iGameDao.delete(1231232); session.commit(); /* 查询全部结果 */ List&lt;Game&gt; games = iGameDao.findAll(); for (Game game:games) { System.out.println(game); } //6、释放资源 session.close();注意：在映射配置文件中用resultType属性告知mybatis要封装到那个实体类。 mybatis与spring的常见三种总结方式：1、用实现mapper的实现类来整合；mybatis与spring整合不变的是：1、创建DataSource;2、创建SqlSessionFactory对象创建DataSource: 创建SqlsessionFactory &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--关联连接池--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!--加载sql映射文件--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/itheima/dao/*.xml&quot;/&gt; &lt;!-- &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/itheima/dao/*.xml&quot;/&gt; --&gt; &lt;/bean&gt;1、使用实现类来实现整合： 2、不用实现类，配置mapper接口： &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.itheima.dao&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;!--&lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; --&gt; &lt;/bean&gt; &lt;!-- Mybatis和Spring的整合 --&gt; &lt;!-- 1. 数据源 : DriverManagerDataSource --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mh&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;123&quot; /&gt; &lt;/bean&gt; &lt;!--创建SqlSessionFactory对象 2. mybatis的SqlSession的工厂: SqlSessionFactoryBean dataSource:引用数据源 MyBatis定义数据源,同意加载配置 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--关联连接池--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!--加载sql映射文件--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/itheima/dao/*.xml&quot;/&gt; &lt;!-- &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/itheima/dao/*.xml&quot;/&gt; --&gt; &lt;/bean&gt; &lt;!--配置mapper接口 spring与mybatis整合的第二种--&gt; &lt;bean id=&quot;iGameDao&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; &lt;!--关联Mapper接口--&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;com.itheima.dao.IGameDao&quot;/&gt; &lt;!--关联SqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; 测试： package com.itheima.test; import com.itheima.dao.IGameDao; import com.itheima.domain.Game; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import java.text.ParseException; import java.text.SimpleDateFormat;public class MabtisSpring { @Test public void test() throws ParseException { //1、加载spring配置 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-mybatis.xml&quot;); //2、获取对象 IGameDao iGameDao = (IGameDao) ac.getBean(&quot;iGameDao&quot;); //3、调用方法 /* 加入一条数据 */ Game game = new Game(); game.setId(6); game.setGname(&quot;天黑请闭眼&quot;); game.setName(&quot;mh&quot;); game.setPassword(&quot;123456&quot;); String date = &quot;2019-09-23&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); game.setBirthday(sdf.parse(date)); iGameDao.saveGame(game); }} 3、使用接口的扫描： 以上代码没变，只改后面部分 &lt;!–mapper接口的扫描，spring与mybatis整合的第三种推荐 3. mybatis自动扫描加载Sql映射文件/接口 : MapperScannerConfigurer sqlSessionFactory basePackage:指定sql映射文件/接口所在的包（自动扫描） 注意：如果使用Dao（mapper）接口包扫描，那么每个Dao（Mapper）接口在Spring容器中的ID名称为类名：例如：IGameDao --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--配置Dao（Mapper）接口所在包路径--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.dao&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt;测试： 只修改要变动部分： @Test public void test() throws ParseException { //1、加载spring配置 ApplicationContext ac = new ClassPathXmlApplicationContext(“spring-mybatis.xml”); //2、获取对象 IGameDao iGameDao = (IGameDao) ac.getBean(“IGameDao”); //3、调用方法 Game game = new Game(); game.setId(7); game.setGname(“天黑请闭眼”); game.setName(“mh”); game.setPassword(“123456”); String date = “2019-09-23”; SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”); game.setBirthday(sdf.parse(date)); iGameDao.saveGame(game); } 注：在整合spring-mybatis时，由于spring-mybatisjar包与mybatisjar包版本起冲突，有时需要设置起对应的版本号报错如下：org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()Ljava/lang/Integer; spring与mybatis的事务整理：创建一个业务层service，service中在创建一个实现serviceimpl: 1、GameSeervice:package com.itheima.service;import com.itheima.domain.Game;public interface GameService { public void saveGame(Game game);} 2、GameSeerviceImpl:package com.itheima.service.impl; import com.itheima.dao.IGameDao;import com.itheima.domain.Game;import com.itheima.service.GameService;import org.springframework.stereotype.Service;import javax.annotation.Resource;//@Service 为IOC注解 @Service(“abc”)public class GameServiceImpl implements GameService { //注入mapper对象 @Resource private IGameDao iGameDao; public void saveGame(Game game) { iGameDao.saveGame(game); //模拟异常，模拟有无事务的情况，如无则会在数据库中插入一条数据，如开启事务管理，此处报异常则不会插入数据 int s = 100/0; iGameDao.saveGame(game); }} 3、当前项目被Spring管理，此时则可以使用Spring注解，但需要去spring-mybatis中开启Spring的注解： &lt;context:component-scan base-package=&quot;com.itheima&quot; /&gt;4、 测试：package com.itheima.test; import com.itheima.dao.IGameDao;import com.itheima.domain.Game;import com.itheima.service.GameService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import java.text.ParseException;import java.text.SimpleDateFormat; public class MabtisSpring { @Test public void test() throws ParseException { //1、加载spring配置 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-mybatis.xml&quot;); GameService gs = (GameService) ac.getBean(&quot;abc&quot;);//获取@Service的名称// //2、获取对象// IGameDao iGameDao = (IGameDao) ac.getBean(“IGameDao”); //3、调用方法 Game game = new Game(); game.setGname(&quot;天黑请闭眼&quot;); game.setName(&quot;mhss&quot;); game.setPassword(&quot;123456&quot;); String date = &quot;2019-09-23&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); game.setBirthday(sdf.parse(date)); gs.saveGame(game);// iGameDao.saveGame(game); } } 5、开启事务在spring-mybatis.xml文件里添加： &lt;bean id=&quot;transactionManage&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--启用spring事务注解功能--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManage&quot;/&gt;测试：在GameServiceImpl中添加事务管理的注解@Transactionalpackage com.itheima.service.impl;import com.itheima.dao.IGameDao;import com.itheima.domain.Game;import com.itheima.service.GameService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import javax.transaction.Transactional;//@Service 为IOC注解@Service(“abc”) //事务管理的注解@Transactional@Transactionalpublic class GameServiceImpl implements GameService { //注入mapper对象 @Resource private IGameDao iGameDao; public void saveGame(Game game) { iGameDao.saveGame(game); //模拟异常，模拟有无事务的情况，如无则会在数据库中插入一条数据，如开启事务管理，此处报异常则不会插入数据 int s = 100/0; iGameDao.saveGame(game); }} MyBatis里ResultMap丶ResultType的区别与ParameterType详解https://blog.csdn.net/Jiale1998/article/details/90047693","categories":[],"tags":[{"name":"Mybatis的配置","slug":"Mybatis的配置","permalink":"http://yoursite.com/tags/Mybatis的配置/"}],"author":"mh"},{"title":"","slug":"java--面试题总结","date":"2019-08-27T03:43:17.375Z","updated":"2019-08-27T03:43:17.375Z","comments":true,"path":"2019/08/27/java--面试题总结/","link":"","permalink":"http://yoursite.com/2019/08/27/java--面试题总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"java--常用模型代码","date":"2019-08-20T05:14:03.616Z","updated":"2019-08-20T05:41:13.337Z","comments":true,"path":"2019/08/20/java--常用模型代码/","link":"","permalink":"http://yoursite.com/2019/08/20/java--常用模型代码/","excerpt":"","text":"一、数据库的连接Connection conn = null;//每一个Connection对象表示一个数据库连接 PreparedStatement ps = null;//数据库操作对象 ResultSet rs =null;//查询结果返回集 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载数据库驱动程序 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mh&quot;,&quot;root&quot;,&quot;123&quot;);//连接数据库以及数据库的账号及密码 System.out.println(&quot;success&quot;); ps = conn.prepareStatement(&quot;select id,gname,name,password,birthday from game&quot;);//找到PreparedStatement接口对象，并执行sql语句，例是查询语句 /* *预处理执行增删改的方式 */ //如增加，其中game是实体类Game的实例化对象 int len = 0; ps = conn.prepareStatement(&quot;insert into game(id,gname,name,password,birthday)values(?,?,?,?,?)&quot;); ps.setInt(1,game.getId()); ps.setString(2, game.getGname()); ps.setString(3, game.getName()); ps.setString(4, game.getPassword()); //方式一：使用java.sql.Timestamp类来获取Date日期型;通过TimeStamp来转换Date型 Timestamp t = new Timestamp(game.getBirthday().getTime()); ps.setTimestamp(5, t); len = ps.executeUpdate(); int len = ps.executeUpdate()//执行数据库增、删、改的操作 rs = ps.executeQuery();//执行数据查询操作","categories":[],"tags":[]},{"title":"java--数据库编程操作-Mh","slug":"java--数据库编程操作","date":"2019-08-15T08:50:10.719Z","updated":"2019-08-20T05:24:33.814Z","comments":true,"path":"2019/08/15/java--数据库编程操作/","link":"","permalink":"http://yoursite.com/2019/08/15/java--数据库编程操作/","excerpt":"","text":"一、连接数据库1、常见几种数据库连接信息：(1) MySQL数据库 String Dirver=”com.mysql.jdbc.Driver”;//驱动程序 String URL=”jdbc:mysql://localhost:3306/db_name”; //连接的URL,db_name为数据库名 String UserName=”username”; //用户名 String Password=”password”; //密码 Class.forName(“com.mysql.jdbc.Driver”); //加载MYSQL JDBC驱动程序 Connection con=DriverManager.getConnection(URL,Username,Password);(2)Microsoft SQL server 数据库 String Driver=”com.microsoft.jdbc.sqlserver.SQLServerDriver”; //驱动程序 String URL=”jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=db_name”; //连接的URL,db_name为数据库 String UserName=”username”; //用户名 String Password=”password”; //密码 Class.forName(“oracle.jdbc.driver.OracleDriver”); //加载Oracal JDBC驱动程序 Connection con=DriverManager.getConnection(URL,Username,Password);(4) Oracle(用thin模式)数据库 String Driver=”oracle.jdbc.driver.OracleDriver”; //驱动程序 String URL=”jdbc:oracle:thin://localhost:1521:orcl”; //连接的URL,orcl为数据库的SID String UserName=”username”; //用户名 String Password=”password”; //密码 Class.forName(“com.microsoft.sqlserver.jdbc.SQLServerDriver”); //加载SeqServer JDBC驱动程序 Connection con=DriverManager.getConnection(URL,Username,Password); 2、连接操作步骤（1）、加载数据库驱动程序，通过Class类完成：Class.forName(驱动程序);（2）、通过DriverManager类根据指定的属性内容连接数据库：java.sql.DriverManager是一个负责取得数据库连接接口（Connection）对象的操作类，此类中定义了一个取得连接的方法：public static Connection getConnection(String url,String user,String password)throws SQLExcption（3）、关闭数据库连接：在Connection接口中定义了close()方法：public void close() throws SQLException例如：一个连接测试：（在连接之前需要将MySQL的jar包配置进去）public class SqlOperate { public static final String DRIVER= “com.mysql.jdbc.Driver”;//数据库的驱动路径 public static final String URL = “jdbc:mysql://localhost:3306/mh”;//连接本地数据库的地址 public static final String USER = “root”;//数据库的账号 public static final String PASSWORD = “123”;//数据库的密码 public static void main(String[] args) { // TODO Auto-generated method stub Connection conn = null;//每一个Connection对象表示一个数据库连接 try { Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USER, PASSWORD); System.out.println(&quot;连接成功&quot;); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } try { conn.close();//关闭连接 } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } }}输出结果：连接成功 二、使用Statement操作数据库数据库连接后就要进行操作，这是可以用Statement接口完成，此接口可以使用Connection中提供的createStatement()方法实例化。此接口定义如下常用方法：（1）、执行数据库更新的SQL语句，例如INSERT,UPDATE,DELETE等语句，返回更新的记录数（普通）：public int executeUpdate(String sql) throwsSQLException（2）、执行数据库查询操作，返回一个结果集对象（普通）：public ResultSet executeQuery(String sql) throws SQLException（3）、关闭操作（普通）：public void close() throws SQLException &lt;!–&gt; 用Statement接口来完成数据库的增删改操作–&gt;1、执行数据库的增加操作：public class SqlOperate { public static final String DRIVER= “com.mysql.jdbc.Driver”;//数据库的驱动路径 public static final String URL = “jdbc:mysql://localhost:3306/mh”;//连接本地数据库的地址 public static final String USER = “root”;//数据库的账号 public static final String PASSWORD = “123”;//数据库的密码 public static void main(String[] args) { // TODO Auto-generated method stub Connection conn = null;//每一个Connection对象表示一个数据库连接 try { Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USER, PASSWORD); System.out.println(&quot;连接成功&quot;); Statement st = (Statement) conn.createStatement();//找到Statement接口对象 String sql = &quot;INSERT INTO game(id,gname,name,password) VALUES(21,&apos;天外飞仙&apos;,&apos;小僵尸&apos;,&apos;123456&apos;)&quot;; int len = st.executeUpdate(sql);//执行Sql语句，并将执行成功的次数返回int用来统计更新行数 System.out.println(&quot;更新行数：&quot;+len); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } try { conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } }}2、执行数据库的更改操作：（由于代码很多与上面代码一样，所以下面代码只给改动部分）String sql = “update game set gname=’大战沙坑’where gname=’天外飞仙’ “;3、执行数据库的删除操作：（由于代码很多与上面代码一样，所以下面代码只给改动部分）String sql = “delete from game where id = 22”;4、因为查询是要查询出来给用户看，所以在查询操作中，就必须有一种结构，可以装下整个的查询结果，而这个结果就使用ResultSet表示，ResultSet接收的类似一张表，但它接收的不是一张表，取出时只需按照数据类型一行一行的取出数据即可。ResultSet接口方法：（1）、移动指针并判断是否有数据（普通）：public boolean next() throws SQLException（2）、取得指定类型的数据（普通）：public 数据 getXxx(列的标记) throws SQLException（3）、关闭结果集（普通）：public void close() throws SQLException例如：结合上面的代码：public class SqlOperate { public static final String DRIVER= “com.mysql.jdbc.Driver”;//数据库的驱动路径 public static final String URL = “jdbc:mysql://localhost:3306/mh”;//连接本地数据库的地址 public static final String USER = “root”;//数据库的账号 public static final String PASSWORD = “123”;//数据库的密码 public static void main(String[] args) { // TODO Auto-generated method stub Connection conn = null;//每一个Connection对象表示一个数据库连接 Statement st = null; //数据库操作对象 ResultSet rs = null ;//将查询返回ResultSet结果集 try { Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USER, PASSWORD); System.out.println(&quot;连接成功&quot;); st = (Statement) conn.createStatement();//找到Statement接口对象// String sql = “INSERT INTO game(id,gname,name,password) VALUES(22,’天外飞仙’,’小僵尸’,’123456’)”;// String sql = “update game set gname=’大战沙坑’where gname=’天外飞仙’ “;//更新数据// String sql = “delete from game where id = 22”; String sql = “select id,gname,name,password from game”; rs = st.executeQuery(sql);//查询 while(rs.next()) {//判断是否有数据 //方式一，根据指定类型获取数据// int id = rs.getInt(“id”);// String gname = rs.getString(“gname”);// String name =rs.getString(“name”);// String password = rs.getString(“password”); //方式二，根据指定类型获取数据。此方式较简单 int id = rs.getInt(1); String gname = rs.getString(2); String name =rs.getString(3); String password = rs.getString(4); System.out.println(id+”\\t”+gname+”\\t”+name+”\\t”+password);//在控制台打印出查询的数据 }// int len = st.executeUpdate(sql);//将执行成功的次数返回int用来统计更新行数// System.out.println(“更新行数：”+len); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } try { rs.close(); st.close(); conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } }} 注：ResultSet中的所有数据都可以通过getString()方法取得，因为String可以接收表中任意类型列的内容；查询时最好不要用“*”查询所有内容，本身这样没问题，但是从查询语句上就很难知道所要的具体列是什么。三、PreparedStatement:属于Statement的子接口，属于预处理操作，与直接使用Statement不同的是，PreparedStatement在操作时会先在数据表中准备好一条Sql语句，但此时的Sql语句的具体内容暂时不设置，而是之后在进行设置。以插入数据为例，数据表中的指针首先指向最后一条数据后，但是里面的内容不知道，等待用户分配。1、预处理操作实际上与在实际生活中占座位是一样，A帮B占座，此时尽管B没有来，但不管B是否来不来，A都会把这个座位占着等待B的到来。 由于PreparedStatement对象已经预编译过，所以其执行速度要高于Statement，因此，对于需要多次执行的Sql语句经常使用PreparedStatement对象操作，以提高效率。 在PreparedStatement中，对于具体的内容是采用“？”的占位符形式出现的，设置是要按照“？”的顺序设置具体的内容2、PreparedStatement的基本操作方法：（1）、执行设置的预处理SQL语句（普通）：public int executeUpdate() throws SQLException（2）、执行数据库查询操作，返回ResultSet(普通)：public ResultSet executeQuery() throws SQLException（3）、指定要设置的索引编号，并设置数据（普通)：public void set 数据类型（int parameterIndex,数据类型 x) throws SQLException（4）、指定要设置的索引编号，并设置java.sql.Date类型的日期内容（普通）：public void setDate(int parameterIndex,Date x) throws SQLException 注：PreparedStatement依然为接口，所以想要取得此接口的实例化对象，应该使用Connection的如下方法：取得PreparedStatement接口对象：public PreparedStatement prepareStatement(String sql) throws SQLException ***关于PreparedStatement接口中的setDate（）方法： 在此接口中定义的setDate()方法可以设置日期内容，但是此方法使用时，后面的Date类型变量是java.sql.Date，而不是java.util.Date，而java.sql.Date是java.util.Date的子类，所以如果要想将一个java.util.Date类型的内容变为java.sql.Date类型的内容应该使用如下的语句形式： java.util.Date temp = new Date();//java.util.Date java.sql.Date bir = new java.sql.Date(temp.getTime());//java.sql.Date 通过PreparedStatement类执行数据库的操作1、执行增加操作： public class SqlOperate { public static final String DRIVER= “com.mysql.jdbc.Driver”;//数据库的驱动路径 public static final String URL = “jdbc:mysql://localhost:3306/mh”;//连接本地数据库的地址 public static final String USER = “root”;//数据库的账号 public static final String PASSWORD = “123”;//数据库的密码 public static void main(String[] args) { // TODO Auto-generated method stub Connection conn = null;//每一个Connection对象表示一个数据库连接 PreparedStatement st = null; //数据库操作对象 ResultSet rs = null ;//将查询返回ResultSet结果集 try { Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USER, PASSWORD); System.out.println(&quot;连接成功&quot;); Scanner sc = new Scanner(System.in); String sql = &quot;insert into game(id,gname,name,password,birthday) values(?,?,?,?,?)&quot;; st = (PreparedStatement) conn.prepareStatement(sql);//找到Statement接口对象 //第一种设置方式// int id = 26;// String gname = “传奇霸业”;// String name = “王世杰”;// String password = “qwee”;// Date birthday = new Date();// st.setInt(1, id);// st.setString(2, gname);// st.setString(3, name);// st.setString(4, password); //第二种直接直接设置 st.setInt(1, 126); st.setString(2, “传奇霸业”); st.setString(3, “传奇霸业”); st.setString(4, “传奇霸业”); st.setString(5, “2019-12-01”);// st.setDate(5, java.sql.Date(birthday.getTime()));// st.setDate(5, new Date(System.currentTimeMillis()));//此方法较常用// st.setDate(5, new Date(new java.util.Date().getTime()));//此方法较常用 int len = st.executeUpdate(); System.out.println(“更新行数:”+len); String sql1 = “select * from game”; rs = st.executeQuery(sql1);//查询 while(rs.next()) { //方式一 int id = rs.getInt(1); String gname = rs.getString(2); String name = rs.getString(3); String password = rs.getString(4); Date birthday = rs.getDate(5) ; System.out.println(id+”\\t”+gname+”\\t”+name+”\\t”+password+”\\t”+birthday); }// int len = st.executeUpdate(sql);// System.out.println(“更新行数：”+len); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } try { rs.close(); st.close(); conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } 注意：关于添加Date类型的设置方法：链接：https://blog.csdn.net/chenluyao_it/article/details/78780967对于Date型数据不能直接用setDate(index,date)直接获取，一般可用以下两种方法解决： 方式一：(推荐) 所有我们需要使用到java.sql.Timestamp这个类来进行转换： Timestamp t = new Timestamp(user.getBirthay().getTime());//user为实体类的对象 ps.setTimestamp(3, t); 这样就可以直接存入数据库！ 方式二： 我们直接将birthday转换成特定格式的字符串String，存入数据库，这样也可以！： DateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); String birthday = df.format(user.getBirthay()); ps.setString(3, birthday);//这样和下面这样都可以！ ps.setObject(3, birthday); 或者我们要想在Servlet中取得日期型数据，先将数据取出存放在String型中,然后用日期格式化操作将String型转为Date型 String birthday = req.getParameter(&quot;birthday&quot;);//取出对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); game.setBirthday(sdf.parse(birthday));此外还有获取当前时间操作的方法：pstmt.setDate(8, new Date(System.currentTimeMillis()));或者：pstmt.setDate(8, new Date(new java.util.Date().getTime())); 另外，setDate（）只能是日期型，最小单位是日。假如需要时分秒需要：pstmt.setTiemstamp(8, new Timestamp(System.currentTimeMillis()));或者：pstmt.setTimestamp(8, new Timestamp(new java.util.Date().getTime())); 2、使用PreparedStatement进行模糊查询public class SqlOperate { public static final String DRIVER= “com.mysql.jdbc.Driver”;//数据库的驱动路径 public static final String URL = “jdbc:mysql://localhost:3306/mh”;//连接本地数据库的地址 public static final String USER = “root”;//数据库的账号 public static final String PASSWORD = “123”;//数据库的密码 public static void main(String[] args) { // TODO Auto-generated method stub Connection conn = null;//每一个Connection对象表示一个数据库连接 PreparedStatement st = null; //数据库操作对象 ResultSet rs = null ;//将查询返回ResultSet结果集 try { Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USER, PASSWORD); System.out.println(&quot;连接成功&quot;); String sql = &quot;select * from game where gname like &apos;传%&apos;&quot;;//模糊查询，查询出带有传字开头的游戏名 st = (PreparedStatement) conn.prepareStatement(sql);//取得PreparedStatement接口对象 rs = st.executeQuery(sql);//查询 while(rs.next()) { //方式一 int id = rs.getInt(1); String gname = rs.getString(2); String name = rs.getString(3); String password = rs.getString(4); Date birthday = rs.getDate(5) ; System.out.println(id+&quot;\\t&quot;+gname+&quot;\\t&quot;+name+&quot;\\t&quot;+password+&quot;\\t&quot;+birthday); } } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } try { rs.close(); st.close(); conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } }}输出结果：连接成功25 传奇霸业 王世杰 qwee 3910-07-2126 传奇霸业 赛达尔多 qwer 1996-05-10 关于MySQL模糊查询的详细语法介绍：https://www.cnblogs.com/panxuejun/p/6140058.html3、使用PreparedStatement进行分页操作：String sql = “select * from game limit 0,5”;//设置查询的范围比如：查询第1条到第10条的数据的sql是：select * from table limit 0,10; -&gt;对应我们的需求就是查询第一页的数据：select * from table limit (1-1)*10,10;详情分页查询：https://www.csdn.net/gather_24/MtTaEg5sOTAwOC1ibG9n.html","categories":[],"tags":[{"name":"java--数据库编程操作","slug":"java-数据库编程操作","permalink":"http://yoursite.com/tags/java-数据库编程操作/"}],"author":"mh"},{"title":"其他知识扩充链接","slug":"其他知识链接","date":"2019-08-13T09:39:28.340Z","updated":"2019-08-29T11:28:16.825Z","comments":true,"path":"2019/08/13/其他知识链接/","link":"","permalink":"http://yoursite.com/2019/08/13/其他知识链接/","excerpt":"","text":"一、Base64介绍：1、https://blog.csdn.net/wufaliang003/article/details/79573512 2、https://blog.csdn.net/wo541075754/article/details/817347703、https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576 4、java对Base64加解密图片：https://blog.csdn.net/ththcc/article/details/82942492，https://www.sohu.com/a/211679265_100084264 二、java中各个包的作用：https://www.cnblogs.com/wumingcong/p/3186608.html 关于java以及javaWeb的技术信息：https://www.cnblogs.com/whgk/p/6399262.html三、Tomcat无法正常启动的原因：（1）、JAVA_HOME配置错误，或者没有配置（2）、端口号已经被占用（可使用netstat -anb 来查看谁占用了端口号） ngrok简介：其实说白了就是你写一个项目，在PC上完美运行，想在手机端访问，只能让手机电脑处于同一局域网内，但是这个技术可以把你的本地IP和端口（例如：localhost:8080）转换为www.baidu.com一样的万网，这样，即使电脑与手机不是在同一局域网内也可以无缝访问，https://blog.csdn.net/a5252145/article/details/84895271 关于input标签中属性的介绍：参考链接：https://www.php.cn/div-tutorial-409384.html","categories":[],"tags":[{"name":"其他知识扩充链接","slug":"其他知识扩充链接","permalink":"http://yoursite.com/tags/其他知识扩充链接/"}],"author":"mh"},{"title":"java--IO-Mh","slug":"java--IO操作","date":"2019-08-12T13:03:40.364Z","updated":"2019-08-15T08:49:51.633Z","comments":true,"path":"2019/08/12/java--IO操作/","link":"","permalink":"http://yoursite.com/2019/08/12/java--IO操作/","excerpt":"","text":"JAVAIO的核心就一句话：如果抽象类或接口之中的抽象方法被子类所覆盖，那么实例化这个子类的时候，所调用的方法一定是被覆写过的方法；所有的操作都在java.io包之中进行定义，而且整个java.io包实际就是5个类和一个接口；5个类：File,InputStream,OutputStream,Reader,Writer一个接口：Serializable 1、文件操作类：File类1、File类主要使用的两种构造方法：（1）、给定一个要操作文件的完整路径（构造）：public File(String pathname)（2）、给定要操作文件的父路径和子文件名称（构造）：public File(File parent,String child)使用File类操作文件的方法：（1）、创建文件（普通）：public boolean createNewFile() throws IOException（2）、删除文件（普通）：public boolean delete()（3）、判断给定路径是否存在(普通)：public boolean exists()**关于路径分隔符：public final String separator如：public static void main(String[] args) throws IOException { File file = new File(“D:”+File.separator+”javaIO.txt”);//文件的路径 if(file.exists()) {//文件存在 System.out.println(“文件存在”); file.delete();//删除文件 }else { System.out.println(“文件不存在创建新文件”); file.createNewFile();//不存在就创建新文件 } } 2、创建目录文件的方法以及File类其他操作方法（1）、找到一个指定路径的父路径（普通）：public File getParentFile()（2）、创建指定目录（普通）：public boolean mkdirs()（3）、取得文件名称（普通）：public String getName()（4）、判断给定的路径是否是文件夹（普通）：public boolean isDirectory()（5）、判断给定的路径是否是文件（普通）：public boolean isFile()（6）、判断是否隐藏（普通）：public boolean isHidden()（7）、文件的最后一次修改日期(普通)：public long lastModified()（8）、取得文件大小，以字节为单位返回（普通）：public long length()（9）、为文件重命名（普通）：public boolean renameTo(File dest)（10）、将目录中所有文件以File对象数组的方式返回代码：public static void main(String[] args) throws IOException { File file = new File(“D:”+File.separator+”javaIO”+File.separator+”a.txt”);//文件的路径 if(!file.getParentFile().exists()) {//目录是否存在// file.mkdir();//只创建一级目录 file.mkdirs();//创建多级目录 } if(file.exists()) {// file.delete();//文件存在删除 }else { file.createNewFile();//文件不存在创建新文件 } System.out.println(“文件名称：”+file.getName());//取得文件名称 System.out.println(“文件名称：”+file.getName()+(file.isDirectory()?”是一个目录”:”不是一个目录”));//判断是否是一个目录 System.out.println(“文件名称：”+file.getName()+(file.isFile()?”是一个文件”:”不是一个文件”));//判断是否是一个文件 System.out.println(“文件名称：”+new File(“D:”+File.separator+”javaIO”).getName() +(new File(“D:”+File.separator+”javaIO”).isDirectory()?”是一个目录”:”不是一个目录”));//判断是否是一个目录 System.out.println(“文件名称：”+file.getName()+(file.isHidden()?”是一个隐藏文件”:”不是一个隐藏文件”)); System.out.println(“最后一次更该日期：” +new SimpleDateFormat(“yyyy年MM月dd日 HH:mm”).format(new Date(file.lastModified())));//最后更改时间 System.out.println(“文件大小：”+new BigDecimal(file.length()/(double)1024) .divide(new BigDecimal(1),2,BigDecimal.ROUND_HALF_UP).doubleValue()+”K”); }输出结果：文件名称：a.txt文件名称：a.txt不是一个目录文件名称：a.txt是一个文件文件名称：javaIO是一个目录文件名称：a.txt不是一个隐藏文件最后一次更该日期：2019年08月13日 00:36文件大小：4.74K 为文件重名名与列出指定的目录内容：public static void main(String[] args) throws IOException { File file = new File(“D:”+File.separator+”javaIO”+File.separator+”a.txt”);//文件的路径 if(!file.getParentFile().exists()) {//目录是否存在// file.mkdir();//只创建一级目录 file.mkdirs();//创建多级目录 } if(file.exists()) {// file.delete();//文件存在删除 File newFile = new File(“D:”+File.separator+”javaIO”+File.separator+”b.txt”);//文件的路径 file.renameTo(newFile);//重命名 } File f = new File(“D:”+File.separator+”Test”); if(f.exists()) { File r[] = f.listFiles(); for(int x=0;x&lt;r.length;x++) { System.out.println(r[x]); } } }列出所有目录里面的内容：public static void main(String[] args) throws IOException { File f = new File(“D:”); print(f);}public static void print(File file) { if(file.isDirectory()) { File result [] = file.listFiles(); if(result !=null) { for(int x = 0;x&lt;result.length;x++) { print(result[x]); } } } System.out.println(file); }} 二、字节流和字符流（1）、字节操作流（JDK 1.0定义）：OutputStream、InputStream（2）、字符操作流（JDK 1.1定义）：Writer、Reader不管是字节流还是字符流的操作，本身都表示资源操作。都会按如下几个步骤进行（1）、如果要操作的是文件，那么首先要通过File类对象找到一个要操作的文件路径（路径不存在就要创建路径）（2）、通过字节流或字符流的子类为字节流或字符流的对象实例化（向上转型）（3）、执行读/写操作（4）、最后一定要关闭资源文件，不管如何操作，最后一定要关闭资源。 1、字节输出流：OutputStream (在OutputStream类之中所有的数据都是以字节数据为主的)，子类为FileOutputStream因为字节输出流是抽象类，所以需要定义抽象类的子类，按照开发原则，子类要为抽象类进行对象的实例化，调用的方法要以父类中定义的方法为主，而具体的是实例化这个父类的子类完成的1、FileOutputStream类的构造方法：（1）、实例化FileOutputStream,主要用于新建数据（构造）：public FileOutputStream(File file) throws FileNotFoundException（2）、实例化FileOutputStream,主要用于追加数据（构造）：public FileOutputStream(File file,boolean append) throws FileNotFoundException 2、OutputStream类定义的3个输出方法（1）、输出单个字节数据（普通）：public abstract void write(int b) throws IOException（2）、输出一组字节数据（普通）：public void write(byte[] b)throws IOException（3）、输出部分字节数据（普通）：public void write(byte[] b,int off,int len)throws IOException如下： public static void main(String[] args) throws IOException { // TODO Auto-generated method stub File file = new File(&quot;D:&quot;+File.separator+&quot;javaIO&quot;+File.separator+&quot;a.txt&quot;);//1、定义文件路径 if(!file.getParentFile().exists()) { file.getParentFile().mkdirs(); }// OutputStream op = new FileOutputStream(file);//2、通过子类实例化父类 OutputStream op1 = new FileOutputStream(file,true);//2、通过子类实例化父类,追加数据，新的数据将自动附加在原始价之后 String data = “Hello mH \\r\\n”;//要输出的数据,其中/r/n是表示换行的意思// op.write(data.getBytes());//3、输出数据，将数据变为字节数组输出 op1.write(data.getBytes());//3、输出数据，将数据变为字节数组输出 op1.write(data.getBytes(),0,5);//3、输出数据，部分输出字节数据// op.close();//4、关闭资源 op1.close();} 2、字节输入流：InputStream,子类为FileInputStream。因为字节输入流是抽象类，所以需要定义抽象类的子类，按照开发原则，子类要为抽象类进行对象的实例化，调用的方法要以父类中定义的方法为主，而具体的是实例化这个父类的子类完成的FileInputStream类构造方法：public FileInputStream(File file) throws FileNotFoundException InputStream类定义的读取数据方法：（1）、读取单个字节数据，每次执行read()方法都会读取一个数据源指定数据，如果读到结尾则返回-1（普通）:public abstract int read() throws IOException（2）、读取多个字节数据，如果现在要读取的数据小于byte的数据，这是read()方法返回值是数据个数；如果开辟的字节数组小于读取的长度并已读完，则返回-1（普通）：public int read(byte[] b) throws IOException（3）、读取指定多个字节数据（普通）：public int read(byte[] b,int off,int len) throws IOException如下：public static void main(String[] args) throws IOException {//一次性读取多个字节数据 // TODO Auto-generated method stub File file = new File(“D:”+File.separator+”javaIO”+File.separator+”a.txt”);//1、定义文件路径 if(file.exists()) { InputStream in = new FileInputStream(file);//2、通过子类实例化父类 byte b[] = new byte[1024];//假设要读取的长度为1024，如果读取的内容大于定义的字节长度，则只会读取该定义大小的位置 int len = in.read(b);//读取数据，并返回读取的总长度 System.out.println(“要读取的数据是：”+new String(b,0,len));//输出读出的数据，并在之中将字节数组变为字符串 in.close(); }}单个字节读取：public static void main(String[] args) throws IOException { // TODO Auto-generated method stub File file = new File(“D:”+File.separator+”javaIO”+File.separator+”a.txt”);//1、定义文件路径 if(file.exists()) { InputStream in = new FileInputStream(file); byte data[] = new byte[1024];//假设读取的长度 int foot = 0;//操作foot数组的脚标、 int temp = 0;//保存每次读取的字节 //第一步 temp = in.read(),读取单个字节，并将内容给temp变量 //第二步， temp !=-1，判断接收到的temp的数值是否为-1，如果为-1，则表示退出循环，如不是则保存数据 while((temp = in.read())!= -1) { data[foot++] = (byte) temp;//保存读取进来的单个字节 } in.close(); System.out.println(“读取的数据为：”+new String(data,0,foot)); }} 3、字符输出流：Writer，子类为FileWriter因为字符输出流是抽象类，所以需要定义抽象类的子类，按照开发原则，子类要为抽象类进行对象的实例化，调用的方法要以父类中定义的方法为主，而具体的是实例化这个父类的子类完成的Writer类的常用方法：（1）、关闭输出流(普通)：public abstract void close() throws IOException（2）、将字符串输出（普通）：public void write(String str) throws IOException（3）、将字符数组输出（普通）：public void write(char[] cbuf) throws IOException（4）、强制性情空缓存（普通）：public abstract void flush() throws IOExceptionWriter类比OutputStream类最方便的一点就是其可以直接使用String型数据输出，并且不再需要将其变为字节数组。如下：public static void main(String[] args) throws IOException { // TODO Auto-generated method stub File file = new File(“D:”+File.separator+”javaIO”+File.separator+”a.txt”);//1、定义文件路径 if(!file.getParentFile().exists()) {//目录不存在创建目录 file.getParentFile().mkdirs(); } Writer out = new FileWriter(file,true);//实例化Writer对象 String data = “mhaiwyl \\r\\n”; out.write(data);//直接输出字符串 out.close();//关闭资源，字符流中如果不关闭资源则无法将内容输出 out.flush();//清空缓存区，如果字符输出流不关闭，这意味着缓冲区的内容不会被输出，此时可以由用户自己调用flush()方法进行强制性的手工清空} 4、字符输入流：Reader,子类为FileReader因为字符输入流是抽象类，所以需要定义抽象类的子类，按照开发原则，子类要为抽象类进行对象的实例化，调用的方法要以父类中定义的方法为主，而具体的是实例化这个父类的子类完成的Reader类常用方法：（1）、关闭输出流(普通)：public abstract void close() throws IOException（2）、读取单个字符(普通)：public int read() throws IOException（3）、将内容读到字符数组中，返回读入的长度(普通)：public int read(char[] cbuf) throws IOException如下：public static void main(String[] args) throws IOException { // TODO Auto-generated method stub File file = new File(“D:”+File.separator+”javaIO”+File.separator+”a.txt”);//1、定义文件路径 if(file.exists()) { Reader in = new FileReader(file);//字符输入流 char data[] = new char[1024];//开辟一个字符数组 int len = in.read(data);//将数据读取到data里面去 System.out.println(“读取内容为：”+new String(data,0,len)); in.close();//关闭资源 }}字符比字节的好处就是在于字符串数据的支持上，而这个好处只是在Writer类中体现，所以字节流中的OutputStream、InputSteream操作方法的对称性相比，字符流的操作并不对称 注：字节流和字符流的区别：区别：字节流在进行IO操作时，直接针对的是操作的数据终端（如文件），而字符流操作时不是直接针对于终端，而是针对于缓存区（理解为内存）的操作，而后由缓存区操作终端（如文件），这属于间接操作，按照这样的方式，如果在使用字节流时不关闭最后的输出流操作，也可以将所有内容输出，而字符流则不行，要么关闭资源，要么调用flush()方法，手动关闭；字节流没有使用到缓冲区，字符流使用了。处理各种数据都可以通过字节流完成，而在处理中文时使用字符流更好；在实际使用中，对于电脑磁盘或者是网络的数据传输，使用最多的数据类型都是字节数据，包括图片、音乐、各种可执行程序 。字节流要比字符流数据更加广泛，但是在进行中文处理的过程中，字符流又要比字节流方便；所以如果使用的话，首先考虑字节流，如果有中文处理的问题才会考虑使用字符流。 例：将一份文件拷贝到另一份文件中（实现由初始化参数输入源文件和拷贝文件的路径，而后执行文件拷贝操作）方式一（边读先写）：public static void main(String[] args) throws IOException {//这就是用参数化输入拷贝的文件路径，在 Run As里面的Configurations里面的Arguments里面写参数 // TODO Auto-generated method stub if(args.length !=2) {//初始化参数不是2，命令有错误 System.out.println(“输入命令错误”); System.exit(1);//程序退出 } long start = System.currentTimeMillis();//执行拷贝命令的开始时间 File file = new File(args[0]);//要复制的源文件 if(!file.exists()) { System.out.println(“源文件程序不存在”); System.exit(1);//程序退出 } File fileCopy = new File(args[1]);//目标文件 InputStream in = new FileInputStream(file); OutputStream output = new FileOutputStream(fileCopy); int temp = 0; while((temp = in.read()) !=-1) {//有内容 output.write(temp); } long end = System.currentTimeMillis();//拷贝完成时间 System.out.println(“拷贝时间：”+(end-start)+”ms”); in.close(); output.close();} 方式二（一次性读取多个字节数组）：public static void main(String[] args) throws IOException { // TODO Auto-generated method stub File file = new File(“D:”+File.separator+”javaIO”+File.separator+”a.txt”);//1、定义文件路径 if(file.exists()) {//复制的文件是否存在 File fileCopy = new File(“D:”+File.separator+”javaIO”+File.separator+ “copy”+File.separator+”b.txt”);//定义要复制到哪里的文件路径 if(!fileCopy.getParentFile().exists()) {//复制到的目录是否存在，不存在则新建一个目录 fileCopy.getParentFile().mkdirs(); } long start = System.currentTimeMillis();//开始时间 InputStream in = new FileInputStream(file);//实例化输入流对象 byte data[] = new byte[1024];//开辟一个字符数组，将源文件的内容读取到次数组中 int len = in.read(data);//将数据读取到data里面去 OutputStream output = new FileOutputStream(fileCopy);//实例化输出流对象 output.write(data);//将之前读取到的内容输出 long end = System.currentTimeMillis(); System.out.println(“拷贝时间：”+(end-start)+”ms”); output.close();//关闭资源 in.close();//关闭资源 }} 三、转换流1、转换操作类：（1）、将字节输出流转换为字符输出流：（OutputStream ——&gt; Writer）:OutputStreanWriter;public static void main(String[] args) throws IOException { // TODO Auto-generated method stub File file = new File(“D:”+File.separator+”javaIO”+File.separator+”abc.txt”); if(!file.getParentFile().exists()) { file.getParentFile().mkdirs();//父路径不存在就创建父目录 } OutputStream output = new FileOutputStream(file);//字节输出流 Writer out = new OutputStreamWriter(output);// out.write(“hsdhaksdakldhaldk”);//输出字符串内容 out.close();//关闭资源}（2）、将字节输入流转换为字符输入流：（InputStream ——&gt; Reader）:InputStreanReader; public static void main(String[] args) throws IOException { // TODO Auto-generated method stub File file = new File(“D:”+File.separator+”javaIO”+File.separator+”abc.txt”); if(!file.getParentFile().exists()) { file.getParentFile().mkdirs();//父路径不存在就创建父目录 } if(file.exists()) { InputStream in = new FileInputStream(file); Reader r = new InputStreamReader(in);//将字节输入流变为字符输入流 char data[] = new char[1024];//假设要读取的长度 int len = r.read(data);//读取数据，返回读取个数 in.close();//关闭字节流 r.close();//关闭字符流 System.out.println(“读取内容：”+new String(data,0,len)); } }四、内存操作流：（1）、字节内存操作流：内存输入流（ByteArrayInputStream）、内存输出流（ByteArrayOutputStream）;（2）、字符内存操作流：内存输入流（ByteArrayReader）、内存输出流（ByteArrayWriter）; 字节内存操作流的构造方法（1）、public ByteArrayInputStream()（2）、public ByteArrayOutputStream() 对比文件操作流和内存操作流文件操作流形式： FileOutputStream : 程序 ——&gt; OutputStream ——&gt; 输出到文件； FileInputStream : 程序 &lt;—— InputStream &lt;—— 内存；内存操作流形式： ByteArrayInputStream : 程序 ——&gt; InputStream ——&gt; 输出到内存； ByteArrayOutputStream : 程序 &lt;—— OutputStream &lt;—— 内存；从概念史昂是反的，但是从使用形式上而言，依然是InputStream负责输入，OutputStream负责输出。例：用内存操作流完成一个字符串大小写字母的转换操作public static void main(String[] args) throws IOException { // TODO Auto-generated method stub String str = “asda sdhad”; InputStream in = new ByteArrayInputStream(str.getBytes());//将数据输出到内存 OutputStream out = new ByteArrayOutputStream();//从内存中读取数据 int temp = 0; while((temp = in.read())!=-1) { out.write((char)Character.toUpperCase(temp));//从内存输出 } String neStr = out.toString(); out.close(); in.close(); System.out.println(neStr);} 五、字符编码（1）、GBK/GBK2312：表示国际中文编码，其中GBK包含简体中文和繁体中文，而GBK2312只有简体（2）、ISO 8859-1： 是一种国际通用编码，可以表示任何文字，但是对于窗格文字需要进行一些转码（3）、UNICODE： 使用了十六进制完成的编码，可以准确地表示出任何语言文字（4）、UTF-8编码：部分编码使用了UNICODE，而一些编码继续使用像IOS 8859-1类型的编码，适合于网络传输，所有项目开发中，都采用此编码 六、打印流为了更好的解决OutputStream或Writer的输出，定义了一个专门的工具类PrintUtil.java用来加强OutputStream和Writer比如你想现在输出数字int或double型例：编写一个自定义的输出功能类： java中专门提供了两个类：字节打印流（PrintStream）和字符打印流类（PrintWriter）;字节打印流与字符打印流类似，以下重点写字节打印流字节打印流构造方法：public PrintStream(OutputStream out)字节打印流常用方法：（1）、通过一个File对象实例化PrintStream类（构造）：public PrintStream(File file) throws FileNotFoundException（2）、接收OutputStream对象，实例化PrintStream（构造）：public PrintStream(OutputStream out)（3）、根据本地环境格式化输出，JDK1.5后增加（普通）：public PrintStream printf(String format,Object..args)（4）、此方法别重载很多次，输出任意数据（普通）：public void print（数据类型 b）（5）、此方法别重载很多次，输出任意数据后换行（普通）：public void println（数据类型 b）如下： public static void main(String[] args) throws IOException { // TODO Auto-generated method stub PrintStream tools = new PrintStream( new FileOutputStream(“D:”+File.separator+”javaIO”+File.separator+”a.txt”)); tools.println(&quot;zs:&quot;); tools.println(&quot;sd&quot;); tools.println(1); tools.print(3); //格式化输出 String name = &quot;啊哈哈&quot;;//姓名 int age = 20;//年龄 double score = 98.26598;//成绩 tools.printf(&quot;姓: %s,年龄: %d,成绩: %5.3f&quot;, name,age,score); tools.close(); InputStream in = new FileInputStream(&quot;D:&quot;+File.separator+&quot;javaIO&quot;+File.separator+&quot;a.txt&quot;); byte b[] = new byte[1024]; int len = in.read(b); System.out.println(&quot;内容：&quot;+new String(b,0,len));}输出结果：内容：zs:sd13姓: 啊哈哈,年龄: 20,成绩: 98.266** 通过以上发现此类结构与代理模式结构很像，但它不是代理；代理设计模式的特点是要在接口上完成、用户调用代理主题方法时依然是接口中定义的方法。而此时的PrintStream类调用的并不是OutputStream类中定义的一系列的write()方法。虽然PrintStream在外表上的操作方法产生了变化，但是实际上依然执行的是OutputStream类定义的操作，其本质没有发生变化。此模式被称为装饰设计模式如果把水枪比喻为打印流（PrintSteam），那么里面放的水就可以比喻为构造方法接收的输出流（FileOutputStream,ByteArrayOutputStream),水枪（PrintSteam）只是提供了一个更好发射的功能，目的还是喷出里面的水。例：在内存流上使用打印流public static void main(String[] args) throws IOException { // TODO Auto-generated method stub String str = “hello world”;//有非字母 InputStream in = new ByteArrayInputStream(str.getBytes());//将数据输出到内存中 OutputStream output = new ByteArrayOutputStream();//从内存中读取数据 PrintStream p = new PrintStream(output);//打印流间接调用了内存输出流 int temp = 0 ; while((temp = in.read()) !=-1) { p.print((char)Character.toUpperCase(temp)); } String s = output.toString();//取数据 in.close(); output.close(); System.out.println(s);}输出结果：HELLO WORLD 注：除了PrintStream类有字符串格式化操作，String类也有：public static String format(String format,Object..args)public static void main(String[] args) throws IOException { // TODO Auto-generated method stub String name = “张三”; int age = 20; double score = 123.324235; String str = String.format(“姓名:： %s,年龄： %d,成绩： %5.3f”, name,age,score); System.out.println(str);} 七、System类System类的3个IO常量：（1）、错误输出（常量）：public static final PrintStream err（2）、系统输出（常量）：public static final PrintStream out（3）、系统输入（常量）：public static final PrintStream inpublic static void main(String[] args) { // 错误输出 try { Integer.parseInt(“abc”); }catch(Exception e){ System.err.println(e); System.out.println(e); }} public static void main(String[] args) throws IOException { //系统输出，没什么实在意义，主要可以理解OutputStream会根据实例化它的子类或对象不同，输出的位置也不同 OutputStream out = System.out;//具备系统输出 out.write(“Hello World”.getBytes());} public static void main(String[] args) throws IOException { // 系统输入，让用户自己输入 InputStream input = System.in; byte data[] = new byte[1024];//开辟空间，接收数据 System.out.print(“请输入数据：”); int len = input.read(data);//等待用户输入，程序进入阻塞状态 System.out.println(“输入的内容是：”+new String(data,0,len)); //上面的代码开辟了固定的空间，只能输入这么多，下面写不需要开辟空间的代码，用户一直输入，直到不输入为止} //此代码可以让用户一直输入，按回车建结束。以下代码有个缺陷，就是不能识别出中文；所以可以使用字符缓冲区——BufferedReader类public static void main(String[] args) throws IOException { StringBuffer buf = new StringBuffer(); System.out.print(“请输入数据：”); int temp = 0; while((temp = input.read()) !=-1) {//用户可以一直输入下去 if(temp == ‘\\n’) {//输入结束 break;//退出循环 } buf.append((char)temp);//保存输入数据 } System.out.println(“输入的内容：”+buf); }输出结果：请输入数据：是的输入的内容：???? 缓冲区操作：BufferedReader(继承——&gt;Reader）（继承：1、FileInputStream——&gt;InputStream——&gt;Object），2（继承：FileReader——&gt;InputStreamReader——&gt;Reader——&gt;Object）,3、（继承：FileOutputStream——&gt;OutputStream——&gt;Object）,4(继承：FileWriter——&gt;OutputStreamWriter——&gt;Writer——&gt;Object)如果把所有的输入数据都放在一起，一次性读取出来，那就避免了中文问题，这一操作可以依靠缓冲区操作流完成，针对缓冲区的读取，IO包中定义了两种类：BufferedInputStream和BufferedReader,考虑到本次操作有中文问题，肯定使用BufferedReader类完成操作，而且这个类中有一个方法可以读取一行数据。另外，BufferedReader构造方法里只能接收Reader类的子类，所以必须使用InputStreamReader类将InputStream变为Reader类型。例如：public static void main(String[] args) throws IOException { BufferedReader buf = new BufferedReader (new InputStreamReader(System.in));//实例化BufferedReader System.out.println(“请输入数据：”); String str = buf.readLine();//读取输入数据 System.out.println(“输入的内容是：”+str);}输出结果：请输入数据：大声道输入的内容是：大声道例子：对输入的数据进行验证，现在要求用户由键盘输入一个数字，而后进行数字的乘法操作，如果输入的不是数字，则需要提醒用户重新输入public static void main(String[] args) throws IOException { BufferedReader buf = new BufferedReader (new InputStreamReader(System.in));//实例化BufferedReader boolean flag = true;//出于循环操作 int num = 0; while(flag) { System.out.println(“请输入数据：”); String str = buf.readLine();//读取输入数据 if(str.matches(“\\d+”)) { num = Integer.parseInt(str); flag = false;//退出循环 System.out.println(“输入的内容是：”+str); }else { System.out.print(“您输入的不是数字！”); } }} 九、ScannerScanner 类的常用方法（1）、从指定的字节输入流中接收内容（构造）：public Scanner(InputStream source)（2）、判断输入的数据是否符合指定的正则标准（普通）：public boolean hasNext(Pattern pattern)（3）、判断有输入内容（普通）：public boolean hasNext()（4）、判断输入的是否为指定的数据类型（普通）：public boolean hasNextXXX()（5）、接收内容（普通）：public String next()（6）、接收内容，进行正则验证（普通）：public String next(Pattern pattern)（7）、接收指定的输入类型（普通）：public int nextXXX（）（8）、设置读取的分隔符（普通）：public Scanner useDelimiter(String pattern)，针对字符串有效，其他数据类型不方便使用**在使用Scanner类接收数据方法（执行nextXXX（））前一定要首先使用hasNextXXX()判断是否有指定格式的数据出现，例1:public static void main(String[] args) throws IOException { Scanner scan = new Scanner(System.in);//实例化Scanner scan.useDelimiter(“\\n”);//只将换行作为换行符h System.out.print(“请输入数据：”); if(scan.hasNext()) {//是否有内容输入 String str = scan.next();//接收数据1 System.out.println(“输入数据：”+str); }else{ System.out.println(“输入的数据不是数字！”); }}例2：public static void main(String[] args) throws IOException { Scanner scan = new Scanner(System.in);//实例化Scanner if(scan.hasNextDouble()) {//判断输入是否为指定类型，程序代码中不能有设置useDelimiter分隔符的存在，否则会读不出正确数据 double d = scan.nextDouble(); System.out.println(“输入数据为：”+d); }else { System.out.println(“输入的不是double类型！！”); }}例3：正则验证：public static void main(String[] args) throws IOException, ParseException { Scanner scan = new Scanner(System.in);//实例化Scanner //利用正则验证 System.out.println(“请输入您的生日：”); if(scan.hasNext(“\\d{4}-\\d{2}-\\d{2}”)) { String str = scan.next(“\\d{4}-\\d{2}-\\d{2}”); Date date = new SimpleDateFormat(“yyyy-MM-dd”).parse(str); System.out.println(date); }else { System.out.println(“输入的不是生日类型”); } //从指定文件中读取数据 Scanner scan = new Scanner(new FileInputStream(new File (“D:”+File.separator+”javaIO”+File.separator+”a.txt”)));//文件输入流 scan.useDelimiter(“\\n”);//设置分隔符 while(scan.hasNext()) {//是否存在数据 System.out.println(scan.next());//取出数据 } scan.close();}*注：在日常开发中，如果通过程序输出数据，建议使用PrintStream打印流，如果存在中文，建议使用PrintWriter打印流。而对于程序输入数据，则建议使用Scannner类完成 十、对象序列化所谓对象序列化指的是可以将在内存中保存的对象数据(主要指的是一个对象里面所包含的属性内容)进行二进制数据传输的一种操作，要想完成这样的二进制操作，就需要实现java.io.Serializable接口，这个接口和Cloneable接口一样，都属于一种标识接口，表示一种能力。 实现序列化与反序列化：java中提供了两个操作类：ObjectOutputStream和ObjectInputStream来实现序列化与反序列化（1）、ObjectOutputStream：继承结构（——&gt;OutputStream——&gt;Object）构造方法：public ObjectOutputStream（OutputStream out) throws IOException对象方法：public final void writeObject（Object obj)throws IOException（2）、ObjectInputStream：继承结构（——&gt;InputStream——&gt;Object）构造方法：public ObjectInputStream（InputStream in) throws IOException对象方法：public final void readObject（Object obj)throws IOException,ClassNotFoundException列如：序列化操作：class Personer implements Serializable{//继承接口，对象可以被实例化 private static final long serialVersionUID = 1L; private String name; private int age; public Personer(String name,int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { // TODO Auto-generated method stub return “姓名：”+this.name+”\\t”+”年龄：”+this.age; }}public class IOoperate { public static void main(String[] args) throws IOException, ParseException { //实现序列化，文件中会显示乱码。需要实现反序列化才能看到原内容 Personer p = new Personer(“mm”,21);//实例化对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream (new File(“D:”+File.separator+”javaIO”+File.separator+”a.txt”))); oos.writeObject(p);//序列化对象 oos.close(); //实现反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream (new File(“D:”+File.separator+”javaIO”+File.separator+”a.txt”))); Personer per = (Personer) ois.readObject(); ois.close(); System.out.println(per); // System.out.println(ois.readObject());// ois.close(); }} 2、transient关键字一般情况下，当一个类的对象被序列化时，这个类中的所有属性都被保存下来，如果现在希望某属性不被保存，就可以使用次关键字声明例如：private transient String name;//不能被序列化private int name;//能被序列化此执行序列化和反序列化操作后，name的值为null； 常见面试分析：请解释java序列化的作用以及实现序列化操作的主要目的是为了保证对象可以以二进制数据的方式进行传输，如果要想实现对象序列化，对象所在的类必须实现java.io.Serializable接口，默认情况下一个对象的所有属性都会被序列化下来，也可以使用transient关键字不被序列化的属性。 本章总结：1、File文件操作类主要是对文件进行操作，关于文件的基本操作，只需牢记其操作的基本方法2、字节流与字符流，一般情况下字节流使用较多，只有在有中文的情况下使用字符流，需注意这两种本身都是抽象类，所以实例化的一般都是子类，关心的方法也是子类中的方法；还有就是使用这两种流最后一定要关闭资源，特别是字符输出流如果不关闭资源，那么内容就不会被输出；字符流有属于自己的缓冲区，而字节流没有。3、内存操作流（ByteArrayInputStream,ByteArrayOutputStream;CharArrayReader,CharArrayWriter）需注意的是他们同文件操作类概念上是相反的，但最后依然是InputStream负责输入，OutputStream负责输出4、打印流：在IO中，输出最好用打印流（PrintStream，PrintWriter），这样就可以方便地输出各种数据类型5、BufferedReader类可以方便的从缓冲区读取数据，主要此类里面有一个readLine（）方法，可以直接读取一行数据。6、使用Scanner可以方便地进行输入流操作","categories":[],"tags":[{"name":"java--IO操作","slug":"java-IO操作","permalink":"http://yoursite.com/tags/java-IO操作/"}],"author":"mh"},{"title":"java--常用类库知识点-Mh","slug":"java--常用类库知识点","date":"2019-08-10T12:18:22.000Z","updated":"2019-08-16T09:13:05.985Z","comments":true,"path":"2019/08/10/java--常用类库知识点/","link":"","permalink":"http://yoursite.com/2019/08/10/java--常用类库知识点/","excerpt":"","text":"一、StringbBffer类#1 StringBuffer类，StringBuffer类适用于被频繁修改的字符串操作上。一般情况都会用String，极少用StringBuffer 常见面试：一个类是否可以继承String类？：不能，因为String类使用了final定义，所以不能被其它类继承将String变为StringBuffer的两个方法：1、直接利用StringBuffer类的构造方法，public StringBuffer（String str):public static void main(String[] args) { String str = “Hello”; StringBuffer sb = new StringBuffer(str); System.out.println(sb); }输出：Hello2、利用StringBuffer类的append（）方法：public static void main(String[] args) { String str = “Hello”; StringBuffer sb = new StringBuffer(); sb.append(str); System.out.println(sb); }输出：Hello 将StringBuffer变为String，利用StringBuffer的toSting（）方法：public static void main(String[] args) { StringBuffer sb = new StringBuffer(); sb.append(“Hello Word!”); String str = sb.toString(); System.out.println(str); }输出结果：Hello Word! StringBuffer的几个常用操作方法1、字符串反转，替换，指定位置上插入字符串：public static void main(String[] args) { StringBuffer sb = new StringBuffer(); sb.append(“Hello Word!”).insert(0,”ai”);//连接并从指定位置插入字符串// System.out.println(sb.reverse());//反转操作 System.out.println(sb.replace(6,12,”MH”));//字符串替换 sb.insert(2,”qqq”); System.out.println(sb); } 常见面试题分析：解释String和StringBuffer的区别？答：String的内容不可改变，而StringBuffer的内容可以改变，如果需要对字符串数据进行频繁修改，只能使用StringBuffer类。 二、Runtime类：在每一个JVM进程中，都会存在一个运行时的操作类的对象，而对象所属的类型就是Runtime类。Runtime类中的构造方法被私有化，是一个标准的单例模式，存在一个static型的方法，可以取得本例实例化对象：public static Runtime getRuntime（）Runtime类方法：1、取得最大可用内存量：public long maxMemory（）2、取得总共可用内存量：public long totalMemory()3、取得空闲内存量：public long freeMemory()4、取得Runtime类的实例化对象：public static Runtime getRuntime()5、运行垃圾收集器、释放垃圾空间：public void gc()方法调用：public static void main(String[] args) { Runtime run = Runtime.getRuntime();//取得Runtime类对象 System.out.println(“1、最大可用：”+run.maxMemory()); System.out.println(“2、总共可用：”+run.totalMemory()); System.out.println(“1、空闲可用：”+run.freeMemory()); String s = “”; for(int x= 0 ;x &lt; 1000;x++) { s += x;//产生垃圾 } System.out.println(“2、最大可用：”+run.maxMemory()); System.out.println(“2、总共可用：”+run.totalMemory()); System.out.println(“2、空闲可用：”+run.freeMemory()); run.gc();//释放垃圾空间 System.out.println(“3、最大可用：”+run.maxMemory()); System.out.println(“3、总共可用：”+run.totalMemory()); System.out.println(“3、空闲可用：”+run.freeMemory()); } 常见面试题分析：什么叫gc()?java是如何处理的？GC（Garbage Collector）:垃圾收集器，可以释放掉垃圾空间所占用的内存。在java中GC有两种操作方式：一种是由JVM不定期的执行GC操作，另外一种是由用户自己手动调用Runtime类的gc()方法进行垃圾空间的释放。 三、System类System类的方法：1、数组拷贝操作：public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)(数组拷贝还有一个格式)：System.arraycopy(源数组名称，源数组开始点，目标数组名称，目标数组开始点，长度)2、取得当前的日期时间，以long型数据返回：public static long currentTimeMillis()代码： public static void main(String[] args) { int a [] = new int[] {1,10,52,41}; for(int x= 0 ;x&lt;a.length;x++) { System.out.print(a[x]+”、”); } int b [] = new int[6]; System.arraycopy(a, 0, b, 0, 4);//数组拷贝 System.out.println(); for(int x= 0 ;x&lt;b.length;x++) { System.out.print(b[x]+”、”); } long start = System.currentTimeMillis();//取得开始时间 String s = “”; for(int x= 0 ; x &lt; 1000;x++) {//产生垃圾 s += x; } long end = System.currentTimeMillis();//取得结束时间 System.out.println(“所花费时间：”+(end-start)+”ms”); }注：在System类中还存在一个方法：public static void gc(),这个方法间接调用了Runtime类中的gc()方法，，不表示一个重写方法。所以System.gc()和调用Runtime.getRuntime().gc()最终效果是完全一样的。 如果希望一个对象收尾时执行一些收尾工作，则对象所在的类可以实现一个finalize()方法，此方法由Object类定义：protected void finalize() throws Throwable注：finalize方法上抛出Throwable表示出现异常或者错误都不会导致程序中断如：class Person11{ public Person11() { System.out.println(“Person类的实例化对象产生”); } @Override protected void finalize() throws Throwable { System.out.println(“Person对象被回收”);//覆写方法 throw new Exception(“不影响程序进行”); }}public class Stringbuffer { public static void main(String[] args) { Person11 p = new Person11(); p = null;//对象成为垃圾 System.gc();//手工清除 System.out.println(“Hello World”); }}输出结果：Person类的实例化对象产生Hello WorldPerson对象被回收 本程序在Person类中覆写了Object类的finalize（）方法，主要可以处理对象回收前的操作，并且为了验证此方法不影响程序执行，特别抛出一个手工异常类对象，当Person对象成为垃圾后（p = null）考虑到自动垃圾收集机制的不确定性，所以手工调用gc()方法进行强制回收，调用后会运行垃圾处理机制，在调用finalize（）方法执行收尾常见面试题分析：请解释final，finally，finalize的区别Final表示终结器，用于定义不能被继承的父类，不能被覆写的方法，常量；Finally是异常处理的出口Finalize（）是Object类定义的一个方法，用于执行对象回收前的收尾操作。 四、日期操作类1 Date类的常用方法（1）、实例化Date类对象(构造)：public Date()（2）、将数字变为Date类对象，long 为日期时间数据(构造)：public Date(long date)（3）、将当前的日期时间变为long型（普通）：public long getTime（）public static void main(String[] args) { Date date = new Date(); System.out.println(date); long num = date.getTime();//将Date变为long型数据public long getTime（） System.out.println(num); Date d = new Date(num);//将long型数据变为Date数据 public Date（long date） System.out.println(d); }输出结果：Sun Aug 11 21:31:22 CST 20191565530282951Sun Aug 11 21:31:22 CST 2019 2 日期格式化操作类：SimpleDateFormat常用方法：（1）、传入日期时间标记实例化对象：public SimpleDateFormat(String pattern)（2）、将日期格式化为字符串数据：public final String format（Date date）（3）、将字符串格式化为日期数据：public Date parse（String source）throws ParseExceptionpublic static void main(String[] args) throws ParseException { Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(“yyyy年-MM月-dd日 HH：mm”); String str = sdf.format(date);//将日期格式化为字符串数据 System.out.println(str); String str1 = “2019-08-11 21:58”; SimpleDateFormat sdf1 = new SimpleDateFormat(“yyyy-MM-dd HH:mm”);// Date d = sdf1.parse(str1);//将字符串格式化为日期数据 System.out.println(d); }输出结果：2019年-08月-11日 22：13Sun Aug 11 21:58:00 CST 2019 注：字符串格式和日期时间标记要统一； 在使用SimpleDateFormat类将字符串变为Date数据时，一定要注意给出的字符串格式要和实例化SimpleDateFormat类对象时的格式相统一字符串可以向基本数据类型（包装类）、日期类型（SimpleDateFormat)进行转换，反过来，他们都可以向字符串进行转换 五、随机数类：Random类代码：public static void main(String[] args) throws ParseException { Random rand = new Random(); for(int x = 0 ;x&lt;10;x++) { System.out.print(rand.nextInt(101)+”、”); } }输出结果：1~100十个随机数 六、数学公式类：Math这个类中所有方法都是static型的方法，而这个类值强调一个方法round（），public static long round(double a)表示四舍五入。代码：public static void main(String[] args) throws ParseException { System.out.println(Math.round(15.6));//计算结果16 System.out.println(Math.round(15.5));//计算结果16 System.out.println(Math.round(-15.6));//计算结果-16 System.out.println(Math.round(-15.5));//计算结果-15 System.out.println(Math.round(-15.51));//计算结果-16 System.out.println(Math.round(15.235));//计算结果15 } 七、大数字操作类1、大整数操作类：BigInteger基本操作方法：（1）、实例化BigInteger对象：public BigInteger(String val)（2）、加法操作：public BigInteger add(BigInteger val)（3）、减法操作：public BigInteger subtract(BigInteger val)（4）、乘法操作：public BigInteger multiply(BigInteger val)（5）、除法操作（不保留余数）：public BigInteger divide(BigInteger val)（6）、除法操作（保留余数）：public BigInteger[] divideAndRemainder(BigInteger val)代码： public static void main(String[] args) throws ParseException { BigInteger b1 = new BigInteger(“201945454545454545454”); BigInteger b2 = new BigInteger(“20194545454545”); System.out.println(“加法结果：”+b1.add(b2)); System.out.println(“减法结果：”+b1.subtract(b2)); System.out.println(“乘法结果：”+b1.multiply(b2)); System.out.println(“除法结果：”+b1.divide(b2)); BigInteger result[] = b1.divideAndRemainder(b2); System.out.println(“除法结果保留余数：”+”商：”+result[0]+”余数：”+result[1]); }输出结果：加法结果：201945474739999999999减法结果：201945434350909090909乘法结果：4078196661156932999988984793388430除法结果：10000000除法结果保留余数：商：10000000余数：4545454 2、大小数操作类：BigDecimal使用BigDecimal完成四舍五入操作（1）、向上进位（常量）：public static final int ROUND_HALE_UP（2）、传递一个double型数据（构造）：public BigDecimal(double val)（3）、除法操作，设置好保留小数位数及进位模式（普通）：public BigDecimal divisor,int scale,int roundingMode)代码：class MyMath{ public static double round(double num,int scale) { BigDecimal b = new BigDecimal(num);//将数据封装在BigDecimal类中 BigDecimal result = b.divide(new BigDecimal(1), scale,BigDecimal.ROUND_HALF_UP);//除法计算,scale表示保留几位小数，BigDecimal(1)表示除数为1 return result.doubleValue();//Number类的方法，返回值为double }}public class Stringbuffer { public static void main(String[] args) throws ParseException { System.out.println(MyMath.round(15.2656, 1)); System.out.println(MyMath.round(-15.5656, 2)); System.out.println(MyMath.round(15.2656, 2)); }}输出结果：15.3-15.5715.27 八、数组操作类：ArraysArrays是一个定义在java.util包中专门进行数组的操作类，在这个雷中定义了所有的与数组有关的基本操作：二分查找、相等判断、数组填充等。常用方法如下：（1）、判断两个数组是否相等，此方法被重载多次，可以判断各种数据类型的数组(普通)：public static boolean equals(int[] a1,int[] a2)（2）、将指定内容填充到数组中。此方法被重载多次，可以填充各种数据类型的数组(普通)：public static void fill（int[] a,int val)（3）、数组排序，此方法被重载多次，可以对各种类型的数组进行排序(普通)：public static void sort(int[] a)（4）、对排序后的数组进行检索，此方法被重载多次，可以对各种类型的数组进行搜索（5）、输出数组信息。此方法被重载多次，可以输出各种数据类型的数组（普通）：public static String toSting（int[] a)测试 ：public static void main(String[] args) throws ParseException { int [] dataA = new int [] {11,22,33};//数组A int [] dataB = new int [] {44,66,11,22,33};//数组B System.out.println(Arrays.equals(dataA,dataB));//数组比较 Arrays.fill(dataA,3);//数组填充 System.out.println(Arrays.toString(dataA));//数组输出 Arrays.sort(dataB);//数组排序 System.out.println(Arrays.toString(dataB));//输出数组信息 System.out.println(Arrays.binarySearch(dataB,33));//对排序后的数组进行检索 }输出结果：false[3, 3, 3][11, 22, 33, 44, 66]2 注Arrays类中还为对象数组排序定义了一个方法：public static void sort(Object[] a)class Person11{ private String name; private int age; public Person11(String name,int age) { this.name = name ; this.age = age; } @Override public String toString() { // TODO Auto-generated method stub return “Person [name =”+this.name+”,age=”+this.age+”]”; }}public class Stringbuffer { public static void main(String[] args) throws ParseException { Person11 per[] = new Person11[] {new Person11(“谢萌”,20),new Person11(“西瓜”,18)}; Arrays.sort(per);//排序对象数组 System.out.println(Arrays.toString(per));//输出对象数组 }} 注：此时尽管语法不报错，但在执行时会出现“ClassCastException”（类转换异常），错误原因为Person11无法转换为Comparable实例，所以普通的对象数组是不能够进行比较的，如果要比较需要比较器的支持九、比较器1、常用比较器：Comparable，定义如下：public interface Comparable{ public int compareTo(T o);}该接口中只提供一个comparableTo()方法，根据文档要求：要排序的数组所在的类一定要实现此接口，此接口返回的是int型数据，而用户覆写此方法时只需要返回3种结果：1（&gt;0）,0(=0),-1(&lt;0);如果（&gt;0）-1就表示结果按升序排序，为1是降序降序代码：class Person11 implements Comparable{ private String name; private int age; public Person11(String name,int age) { this.name = name ; this.age = age; } @Override public String toString() { // TODO Auto-generated method stub return “ 姓名 =”+this.name+” age=”+this.age+”\\n”; } @Override public int compareTo(Person11 o) { if(this.age&gt;o.age){ return 1; }else if(this.age&lt;o.age){ return -1; } else{ retuen 0; } // if(this.age&gt;0) { // return -1; // }else if(this.age&lt;0){ // return 1; // }else { // return 0; // } }}public class Stringbuffer { public static void main(String[] args) throws ParseException { Person11 per[] = new Person11[] {new Person11(“谢萌”,20),new Person11(“西瓜”,18),new Person11(“西瓜”,16)}; Arrays.sort(per);//排序对象数组 System.out.println(Arrays.toString(per));//输出对象数组 }}输出结果：[ 姓名 =西瓜 age=16, 姓名 =西瓜 age=18, 姓名 =谢萌 age=20] 所以，后续只要牵扯到对象数组排序时首先就要想到Comparable2、挽救的比较器ComparatorComparable比较器是一个类定义时就已经具备的功能，那如果现在有如下的一个已经定义好的类则该如何排序？定义：public interface Comparator{ public int compare(T o1,T o2); public boolean equals(Object obj);}在compare（）方法上存在两个参数用于比较大小，而要想使用这个接口，需要单独定义一个比较规则类。如：class Person11 {//已经定义好了的一个类 private String name; private int age; public Person11(String name,int age) { this.name = name ; this.age = age; } @Override public String toString() { // TODO Auto-generated method stub return “ 姓名 =”+this.name+” age=”+this.age+”\\n”; } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public int getAge() { return age; }}class PersonComparator implements Comparator{//定义比较规则类 @Override public int compare(Person11 o1, Person11 o2) { if(o1.getAge()&gt;o2.getAge()) { return 1; } if(o1.getAge()&lt;o2.getAge()) { return -1; } return 0; }}public static void main(String[] args) throws ParseException {//类中调试 Person11 per[] = new Person11[] {new Person11(“谢萌”,20),new Person11(“西瓜”,18),new Person11(“西瓜”,16)}; Arrays.sort(per,new PersonComparator());//排序对象数组 System.out.println(Arrays.toString(per));//输出对象数组 }输出结果：[ 姓名 =西瓜 age=16, 姓名 =西瓜 age=18, 姓名 =谢萌 age=20] 十、对象克隆克隆就是对象的复制操作，在Object类中存在一个clone（）方法。克隆方法：protected Object clone() throws CloneNoteeSupportedExceprion;此方法上抛出了一个不支持的克隆异常，这个异常表示的是要克隆对象的类必须实现Cloneable接口，但是要实现Cloneable接口没有任何方法，所以这个接口属于标志接口，只表示一种能力实现对象克隆操作：class Person11 implements Cloneable{//表示一种能力，没有方法覆写 private String name; private int age; public Person11(String name,int age) { this.name = name ; this.age = age; } @Override public String toString() { // TODO Auto-generated method stub return “ 姓名 =”+this.name+” age=”+this.age+”\\n”; } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override protected Object clone() throws CloneNotSupportedException {//调用父类克隆 // TODO Auto-generated method stub return super.clone(); }}public class Stringbuffer { public static void main(String[] args) throws CloneNotSupportedException { Person11 p = new Person11(“张三”,18); Person11 p1 = (Person11) p.clone(); pe1.setName(“麻子”); System.out.println(p+””+p1); }}输出结果： 姓名 =张三 age=18 姓名 =麻子 age=18 十一、正则表达式1、常用正则匹配符号 1、字符：匹配单个字符（1）、表示匹配字母a: a（2）、匹配转义字符“\\”: \\（3）、匹配转义字符“\\t”: \\t（4）、匹配转移而字符“\\n”: \\n 2、一组字符：任意匹配里面的一个单个字符（1）、表示的可能是字母a,可能是b，或者是c： [abc]（2）、表示不是字母a、字母b、字母c中的任意一个： [^abc]（3）、表示全部字母中的任意一个： [a-zA-Z]（4）、表示全部数字中的任意一个： [0-9]3、边界匹配：在以后编写JavaScript使用正则时要使用到（1）、表示一组正则的开始： ^（2）、表示一组正则的结束： $4、简写表达式：每一位出现的简写标记也只表示一位（1）、表示任意一位字符： .（2）、表示任意一位的数字，等价于[0-9]: \\d（3）、表示任意的一位非数字，等价于[^0-9]: \\D（4）、表示任意的一位字母，数字，,等价于[a-zA-Z0-9_]: \\w（5）、表示任意的一位非字母，数字，,等价于[^a-zA-Z0-9_]: \\W（6）、表示任意的一位空格，如\\n,\\t等： \\s（7）、表示任意的一位非空格： \\S5、数量表示：之前的所有正则都只是表示一位，如果想要表示多位，则就需要数量表示（1）、此正则出现0此或一次： 正则表达式？（2）、此正则出现0次、1次或多次： 正则表达式*（3）、次正则出现1次或多次： 正则表达式+（4）、次正则出现n次： 正则表达式{n}（5）、次正则出现n次以上： 正则表达式{n，}（6）、次正则出现n~m次： 正则表达式{n,m}6、逻辑表示：与、或、非（1）、表达式A后紧跟着表达式B： 正则表达式A正则表达式B（2）、表达式A或者表达式B，二者任选一个： 正则表达式A|正则表达式B（3）、将多个子表达式合成一个表达式，作为一组出现：（正则表达式） 2、String类对正则的支持操作方法：（1）、与指定正则匹配(普通)：public boolean matches(String regex)（2）、替换满足指定正则的全部内容：public String replaceAll(String regex,String replacement)（3）、替换满足指定正则的首个内容: public String replaceFirst(String regex,String replacement)（4）、按照指定正则全拆分： public String[] split(String regex)（5）、按照指定正则拆分为指定个数： public String[] split(String regex,int limit)代码：public static void main(String[] args) { String s = “12abcd31253tasd”; String s1 = “aabbaaab”; if(s1.matches(“\\d+”)) { System.out.println(“是数字”); }else { System.out.println(“不是数字”); } String r = “[ab]+”; System.out.println(s1.matches(r)); System.out.println(s.replaceAll(“[a-z]”, “0”));//替换满足指定正则的全部内容 System.out.println(s.replaceFirst(“\\d”, “q”));//替换满足指定正则的首个内容 System.out.println(s.replaceAll(“[a-z]+”, “0”));//替换满足指定正则的首个内容 String regex = “\\d”;//数字出现一次[0-9] String result[] = s.split(regex);//按照指定正则全拆分 for(int x = 0 ; x&lt;result.length;x++) { System.out.print(result[x]+”、”); } }输出结果：不是数字true120000312530000q2abcd31253tasd120312530、、abcd、、、、、tasd、 例1：验证一个字符串是否是整型数据，如果是将其变为int型数据，而后执行乘法操作public static void main(String[] args) { String str =”100”; String regex = “\\d+”; if(str.matches(regex)) { int s = Integer.parseInt(str); System.out.println(“积为：”+ss); }else { System.out.println(“字符串不是纯数字组成!”); } }输出结果：10000例2：验证字符串是否为小数，如果是将其变为double型数据，而后执行乘法操作public static void main(String[] args) { String str =”100.22”; String regex = “\\d+(\\.\\d+)?”;//小数点（.）之后必须存在数字才有意义，所以使用了括号运算符，将“.”和小数位一起进行验证((\\.\\d+)?)整体出现0次或者一次 if(str.matches(regex)) { double s = Double.parseDouble(str); System.out.println(“积为：”+s*s); }else { System.out.println(“字符串不是纯数字组成!”); } }输出结果：积为：10044.0484例3：输入一个字符串，按照“年-月-日 时：分：秒”的形式，如果正确，则将其变为Date型数据public static void main(String[] args) throws ParseException { String str =”2019-08-12 15:33:50”; String regex = “\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}”; if(str.matches(regex)) { SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); System.out.println(sdf.parse(str));//将字符串转换为日期格式 } }输出结果：Mon Aug 12 15:33:50 CST 2019例4：一个用户名只能由字母、数字、组成，其长度只能是6~15位public static void main(String[] args) throws ParseException { String str =”201905_asdf”; String regex = “\\w{6,15}”; if(str.matches(regex)) { System.out.println(“字符串合法”); }else { System.out.println(“字符串不合法”); } }输出结果：字符串合法例5：编写一个正则表达式，验证电话号码是否正确（以下有关于几种电话号码的写法）（1）、50021689 ——&gt; \\d{7,8}表示电话号码为7位或者8位（2）、01250021689 ——&gt; (\\d{3,4})?\\d{7,8} 前面三位可能出现也可能不出现（3）、012-50021689 ——&gt; (\\d{3,4})?-?\\d{7,8} “-“可能出现也可能不出现（4）、(012)-50021689 ——&gt; ((\\d{3,4}|\\(\\d{3,4}\\))-?)?\\d{7,8}（5）、(012)50021689 ——&gt;((\\d{3,4}|\\(\\d{3,4}\\))-?)?\\d{7,8}public static void main(String[] args) throws ParseException { String str =”012-52221698”; String regex = “((\\d{3,4}|\\(\\d{3,4}\\))-?)?\\d{7,8}”;//此表达式包含以上5种 if(str.matches(regex)) { System.out.println(“字符串合法”); }else { System.out.println(“字符串不合法”); } }例6：要求验证一个Email地址，Email地址的用户名由字母、数字和_和.组成，其中不能以数字和.开头，并且Eemail地址的域名只能是.com,.cn,.netpublic static void main(String[] args) throws ParseException { String str =”.@.15.com”; String regex = “[a-zA-Z_][a-zA-Z_0-9\\.]@[a-zA-Z_0-9\\.]+\\.(com|cn|net)”; if(str.matches(regex)) { System.out.println(“字符串合法”); }else { System.out.println(“字符串不合法”); } }输出结果：字符串合法例7：要求其组成原则为“姓名：年龄：成绩：|姓名：年龄：成绩：|…”,姓名只能是字母组成，年龄只能是数字，成绩可能有小数public static void main(String[] args) throws ParseException { String str =”mh:21:99|wyl:22:99.5|ly:20:89”; String regex = “([a-zA-Z]+:\\d{1,3}:\\d{1,3}(\\.\\d{1,2})?\\|)+” + “([a-zA-Z]+:\\d{1,3}:\\d{1,3}(\\.\\d{1,2})?)?”; if(str.matches(regex)) { System.out.println(“字符串合法”); }else { System.out.println(“字符串不合法”); } }输出结果：字符串合法将上面按成绩由高到低排序？既然是排序就想到的方是Arrays.sort()，但是现在可以将这些数据变为对象数组排序，利用比较器完成代码：class Student11 implements Comparable{ private String name; private int age; private double score; public Student11(String name,int age,double score) { this.name = name; this.age = age; this.score = score; } @Override public String toString() { // TODO Auto-generated method stub return “姓名：”+this.name+”,年龄：”+this.age+”,成绩：”+this.score+”\\n”; } @Override public int compareTo(Student11 o) { // TODO Auto-generated method stub if(this.score&gt;o.score) { return -1; } if(this.score&lt;o.score) { return 1; } return 0; }}public static void main(String[] args) throws ParseException { String str =”mh:21:99|wyl:22:99.5|ly:20:89”; String regex = “([a-zA-Z]+:\\d{1,3}:\\d{1,3}(\\.\\d{1,2})?\\|)+” + “([a-zA-Z]+:\\d{1,3}:\\d{1,3}(\\.\\d{1,2})?)?”; if(str.matches(regex)) { System.out.println(“字符串合法”); String result[] = str.split(“\\|”);//按照正则拆分 System.out.println(Arrays.toString(result)); Student11 stu[] = new Student11[result.length]; for(int x = 0;x&lt;result.length;x++) { String temp[] = result[x].split(“:”); stu[x] = new Student11(temp[0], Integer.parseInt(temp[1]), Double.parseDouble(temp[2])); } Arrays.sort(stu); System.out.println(Arrays.toString(stu)); }else { System.out.println(“字符串不合法”); } }输出结果：字符串合法[mh:21:99, wyl:22:99.5, ly:20:89][姓名：wyl,年龄：22,成绩：99.5, 姓名：mh,年龄：21,成绩：99.0, 姓名：ly,年龄：20,成绩：89.0 十二、反射机制1、通过反射实例类1、认识反射（反一般指通过对象找到类）：方式一，通过Object类的getClass（）方法取得，基本不用class Persoon{ public Persoon() { // TODO Auto-generated constructor stub }}public class Reflex { public static void main(String[] args) { Persoon p = new Persoon();//实例化对象 System.out.println(p.getClass().getName()); }}输出结果：object.Persoon方式二、使用类.class取得class Persoon{ public Persoon() { // TODO Auto-generated constructor stub }}public class Reflex { public static void main(String[] args) { Class&lt;?&gt; cl = Person.class;//取得Class对象 System.out.println(cl.getName());//反着操作 }} 方式三：使用Class类内部定义的一个static方法（被主要使用）；取得Class类对象：public static Class&lt;?&gt; forName(String className) throws ClassNotFoundExceptionclass Persoon{ public Persoon() { // TODO Auto-generated constructor stub }}public class Reflex { public static void main(String[] args) { Class&lt;?&gt; cl = Class.forName(“object.Person”);//取得Class对象 System.out.println(cl.getName());//反着操作 }} 2、通过反射实例化对象：public T newInstance() throws InstantiationException,IllegalAccessException 通过反射机制实现工厂设计模式之前工厂模式接口的子类有新加的，那么工厂类就要跟着修改，造成这个很大的问题在于new，现在用反射机制来修改：interface Fruit{ public void eat();//定义一个吃的方法}class Apple implements Fruit{ @Override public void eat() { System.out.println(“吃苹果”); }}class Orange implements Fruit{ @Override public void eat() { System.out.println(“吃橘子”); }}class Factory{ public static Fruit getInstance(String className) { Fruit f = null; try { f = (Fruit) Class.forName(className).newInstance();//反射实例化 } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } return f; }}public class Reflex { public static void main(String[] args) throws ClassNotFoundException { Fruit f = Factory.getInstance(“object.Apple”);//取得苹果类 Fruit f1 = Factory.getInstance(“object.Orange”);//取得橘子类 f.eat(); f1.eat(); }}输出结果：吃苹果吃橘子","categories":[],"tags":[{"name":"java--常用类库知识点","slug":"java-常用类库知识点","permalink":"http://yoursite.com/tags/java-常用类库知识点/"}],"author":"mh"},{"title":"我的第一篇博客文章-Mh","slug":"java--多线程知识点","date":"2019-08-09T12:00:00.000Z","updated":"2019-08-09T17:25:58.783Z","comments":true,"path":"2019/08/09/java--多线程知识点/","link":"","permalink":"http://yoursite.com/2019/08/09/java--多线程知识点/","excerpt":"","text":"一、多线程的实现：java中，要想实现多线程的程序，就必须依靠一个线程的主体类，但是这个主题类在定义时也需要一些特殊要求，这个类可以继承Thread类或实现Runnable接口来定义完成#1、继承Thread类实现多线程注意：run()方法为Thread类中覆写的方法，此方法是线程的主体方法，但是在调用方法时并不是直接调用，而是用java中提供的start()方法间接调用，因为直接调用不能体现出多个线程之间以交互的方式来运行。例子：class MyThread extends Thread{//线程的主体类 private String title; public MyThread(String title) { this.title = title; } @Override public void run() { // TODO Auto-generated method stub for(int x = 0;x &lt; 10;x++) { System.out.println(this.title+”运行 ：x=”+x ); } }}public class MultiThreading { public static void main(String[] args) { MyThread mt = new MyThread(&quot;线程A&quot;); MyThread mt1 = new MyThread(&quot;线程B&quot;); MyThread mt2 = new MyThread(&quot;线程C&quot;); mt.start(); mt1.start(); mt2.start(); }}输出结果：线程A运行 ：x=0线程C运行 ：x=0线程B运行 ：x=0线程C运行 ：x=1线程A运行 ：x=1线程C运行 ：x=2线程C运行 ：x=3………….. #2、利用Runnable接口实现多线程（利用Thread很方便，但它只能实现单继承，所以利用Runnabl接口，他可以有效的避免但继承的局限）注意：对于实现了Runnable接口后，要想启动多线程，之前Thread类的start()方法不能直接继承使用了，此时则需要利用Thread类启动多线程例如：public static void main(String[] args) { MyThread mt = new MyThread(&quot;线程A&quot;); MyThread mt1 = new MyThread(&quot;线程B&quot;); MyThread mt2 = new MyThread(&quot;线程C&quot;); new Thread(mt).start(); new Thread(mt1).start(); new Thread(mt2).start(); }#3多线程两种方式的区别：（1）、多线程的两种实现方式都是需要一个线程的主类，而这个类可以实现Runnable接口或继承Thread类。不管使用何种方式都必须在子类中覆写run()方法。此方法为线程的主方法；（2）、Thread类是Runnable接口的子类，使用Runnable接口可以避免单继承局限，以更加方便地实现数据共享的概念。 #4线程的操作状态主要有5种：创建状态，就绪状态，运行状态、堵塞状态，终止状态 #5线程的主要操作方法1、线程的命名和取得（1）、实例化线程对象，接受Runnable接口子类对象，同时设置线程名称。（类型构造）：public Thread(Runnable target,String name)（2）、设置线程名称（类型：普通）：public final void setName(String name)（3）、取得线程名称（类型：普通）：public final String getName()（4）、取得当前线程对象的方法：public static Thread currentThread()。例如：package object; class MyThread implements Runnable{//线程的主体类 private int ticket = 5;//一共5张票 public MyThread() { // TODO Auto-generated constructor stub } @Override public void run() { // TODO Auto-generated method stub for(int x = 0;x &lt; 10;x++) { if(ticket&gt;0) //获取当前线程名称以及票数 System.out.println(Thread.currentThread().getName()+”运行 ：ticket=”+this.ticket– ); } }}public class MultiThreading { public static void main(String[] args) { MyThread mt = new MyThread(); new Thread(mt,&quot;线程A&quot;).start();//设置当前线程名称 new Thread(mt,&quot;线程B&quot;).start(); new Thread(mt,&quot;线程C&quot;).start(); }}输出结果：线程A运行 ：ticket=5线程C运行 ：ticket=3线程B运行 ：ticket=4线程C运行 ：ticket=1线程A运行 ：ticket=2 #注：线程是依赖于进程，在进程的基础上划分。在java中每一个JVM运行就是进程，每一个JVM进程都至少启动两个线程：main个gc #线程的休眠：Thread.sleep(1000)每次休眠1000毫秒 #6 线程的优先级方法和常量：（1）、最高优先级，数值为10（常量） public static final int MAX_PRIORITY（2）、中等优先级，数值为5 （常量） public static final int NORM_PRIORITY（3）、最低优先级，数值为1 （常量） public static fnial int MIN_PRIORITY（4）、设置线程优先级 （普通） public final void setPriority(int newPriority)（5）、取得线程优先级 （普通） public final int getPriority()例如：class MyThread implements Runnable{//线程的主体类 private int ticket = 5;//一共5张票 public MyThread() { // TODO Auto-generated constructor stub } @Override public void run() { // TODO Auto-generated method stub for(int x = 0;x &lt; 10;x++) { try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } if(ticket&gt;0) //获取当前线程名称以及票数还有优先级 System.out.println(Thread.currentThread().getName() +”线程优先级：”+Thread.currentThread().getPriority()+”运行 ：ticket=”+this.ticket– ); } }}public class MultiThreading { public static void main(String[] args) { MyThread mt = new MyThread(); Thread t1 = new Thread(mt,&quot;线程A&quot;);//定义线程对象 Thread t2 = new Thread(mt,&quot;线程B&quot;);//定义线程对象 Thread t3 = new Thread(mt,&quot;线程C&quot;);//定义线程对象 t2.setPriority(Thread.MAX_PRIORITY);//设置为最高优先级 t3.setPriority(Thread.MIN_PRIORITY);//设置最低优先级 t3.setPriority(Thread.MIN_PRIORITY);//设置最低优先级 t1.start(); t2.start(); t3.start();// new Thread(mt,”线程A”).start();//启动线程// new Thread(mt,”线程B”).start();// new Thread(mt,”线程C”).start(); }}输出结果：线程A线程优先级：5运行 ：ticket=5线程B线程优先级：10运行 ：ticket=4线程C线程优先级：1运行 ：ticket=3线程B线程优先级：10运行 ：ticket=2线程A线程优先级：5运行 ：ticket=1 #7 线程的同步与死锁 #7.1 同步问题例如：class MyThread implements Runnable{//线程的主体类 private int ticket = 5;//一共5张票 public MyThread() { // TODO Auto-generated constructor stub } @Override public void run() { // TODO Auto-generated method stub for(int x = 0;x &lt; 10;x++) { if(ticket&gt;0) { try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } //获取当前线程名称以及票数 System.out.println(Thread.currentThread().getName() +&quot;线程优先级：&quot;+Thread.currentThread().getPriority()+&quot;运行 ：ticket=&quot;+this.ticket-- ); } } }}public class MultiThreading { public static void main(String[] args) { MyThread mt = new MyThread();// Thread t1 = new Thread(mt,”线程A”);//定义线程对象// Thread t2 = new Thread(mt,”线程B”);//定义线程对象// Thread t3 = new Thread(mt,”线程C”);//定义线程对象// t2.setPriority(Thread.MAX_PRIORITY);//设置为最高优先级// t3.setPriority(Thread.MIN_PRIORITY);//设置最低优先级// t3.setPriority(Thread.MIN_PRIORITY);//设置最低优先级// t1.start();// t2.start();// t3.start(); new Thread(mt,&quot;线程A&quot;).start();//启动线程 new Thread(mt,&quot;线程B&quot;).start(); new Thread(mt,&quot;线程C&quot;).start(); new Thread(mt,&quot;线程D&quot;).start(); }}此时输出结果：线程D线程优先级：5运行 ：ticket=3线程A线程优先级：5运行 ：ticket=4线程A线程优先级：5运行 ：ticket=1线程C线程优先级：5运行 ：ticket=-1线程B线程优先级：5运行 ：ticket=0线程D线程优先级：5运行 ：ticket=-2以上代码结果：包含有负数，因为以上代码run()方法中，（1）判断票数是否大于0，大于0表示有票卖，（2）大于0，且将票卖出去。但是在（1）和（2）步中加入了延迟操作，那么就有可能在一个线程还没有对票数进行减操作前，其他线程就已经减少了，所以出现为负数的情况，要解决 此问题就需要用到同步，使用synchronized关键字。##注意在进行同步操作时必须要设置一个同步的对象，而这个对象应该理解为当前对象this例如：为简化代码量，只需将上面里面的代码里将run()方法里面加上synchronized关键字，此方法为同步代码块（方式一）public void run() { // TODO Auto-generated method stub for(int x = 0;x &lt; 10;x++) { synchronized(this) { if(ticket&gt;0) {//判断是否有票 try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } //获取当前线程名称以及票数还有优先级 System.out.println(Thread.currentThread().getName() +”线程优先级：”+Thread.currentThread().getPriority()+”运行 ：ticket=”+this.ticket– ); } } } }}（2）、同步方法：class MyThread implements Runnable{//线程的主体类 private int ticket = 5;//一共5张票 public MyThread() { // TODO Auto-generated constructor stub } @Override public void run() { for(int x = 0 ;x &lt; 10 ; x++) { this.sal(); } } public synchronized void sal() {//定义同步方法 if(this.ticket&gt;0) { try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +” 优先级：”+Thread.currentThread().getPriority()+” 运行：”+this.ticket–); } }}public class MultiThreading { public static void main(String[] args) { MyThread mt = new MyThread(); new Thread(mt,”线程A”).start();//启动线程 new Thread(mt,”线程B”).start(); new Thread(mt,”线程C”).start(); new Thread(mt,”线程D”).start(); }} #注，补充说明：加入同步后明显比不加入同步慢，所以同步的代码性能很低，安全性高。 #同步与异步有何区别？分别在什么情况下使用？：如果一块数据要在多个线程间进行共享，例如正在写的数据，以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取；当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，很多情况下采用异步途径往往更有效率 #注：abstract的method是否可同时是static、native或synchronized？ ：都不能和“abstract”同时声明方法 #8 死锁：同步是指一个线程要等待另外一个线程执行完毕才会继续执行的一种操作形式，但问题也来了，例如：张某想要王某的1000元钱，王某想要张某的物品，但此时张某在等待王某先给钱，王某在等待张某先给物品。此时就陷入了死锁的状态，两人都得不到想要的；即所谓的死锁就是指两个线程都在等待彼此先完成，造成了程序的停滞状态例如：class Zhang{//定义张某的类 public void say() {//张某说 System.out.println(“王某你给我1000元钱，这个手机就是你的了”); } public void get() { System.out.println(“张某得到了钱”); }}class Wang{//定义张某的类 public void say() {//张某说 System.out.println(“张某你给我手机，这个1000元就是你的了”); } public void get() { System.out.println(“王某得到了手机”); }} class MyThread implements Runnable{ private static Zhang z = new Zhang();//实例化static型对象，数据共享 private static Wang w = new Wang();//实例化static型对象，数据共享 boolean flag = false;//声明标记，用于判断哪个对象先执行 @Override public void run() {//线程的主体类 if(flag) { synchronized(z) { z.say(); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } synchronized(w) { z.get();//要等王某同意才会得到一千元 } } }else { synchronized(w) { try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } w.say(); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } synchronized(z) { w.get();//要等张某同意才会得到手机 } } } }}public class MultiThreading { public static void main(String[] args) { MyThread mt = new MyThread();//实例化线程对象 MyThread mt1 = new MyThread(); mt.flag = true;//设置标记 mt1.flag = false; Thread t = new Thread(mt);//实例化Thread类对象 Thread t1 = new Thread(mt1); t.start();//启动线程 t1.start(); }}输出结果：王某你给我1000元钱，这个手机就是你的了张某你给我手机，这个1000元就是你的了此时结果会陷入卡顿，因为这两个人都在等对方回复，要想解开。只能对其中一个get()方法的synchronized的同步取消即可 ##线程间的经典操作案例class Message{ private String title;//保存信息的标题 private String content;//保存信息的内容 public void setTitle(String title) { this.title = title ; } public void setContent(String content) { this.content = content; } public String getTitle() { return title; } public String getContent() { return content; }} class Producer implements Runnable{//定义生产者 private Message msg= null; public Producer(Message msg) { this.msg = msg; } @Override public void run() { for(int x = 0 ; x &lt; 10 ;x++) { if(x%2 == 0) { this.msg.setTitle(“缪和”); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } this.msg.setContent(“皮皮月来打游戏了”); }else {// try {// Thread.sleep(1000);// } catch (InterruptedException e) {// // TODO Auto-generated catch block// e.printStackTrace();// } this.msg.setTitle(“皮皮月”); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } this.msg.setContent(“缪和来打游戏了啦”); } } }}class Consumer implements Runnable {//定义取出者 private Message msg1 = null; public Consumer(Message msg1) { this.msg1 = msg1; } @Override public void run() { for(int x = 0 ;x &lt; 10;x++) { try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(this.msg1.getTitle()+”&gt;&gt;&gt;”+this.msg1.getContent()); } }}public class MultiThreading { public static void main(String[] args) { Message m = new Message();//定义msg对象，用于保存和取出数据 new Thread(new Producer(m)).start(); new Thread(new Consumer(m)).start(); }} #以上代码执行会出现设置的数据错位以及数据会重复取出和重复设置，为了解决此问题，需要用到Object类中定义的3个方法完场线程的操作。改正代码如下：（1）、线程的等待（普通）：public final void wait() throws InterruptedException（2）、唤醒第一个等待线程(普通)：public final void notify()（3）、唤醒全部等待线程（普通）：public final void notifyAll() #只需修改Message类即可：class Message{ private String title;//保存信息的标题 private String content;//保存信息的内容 private boolean flag = true;//flag 为true表示可以生产，但是不能取走，flag为false表示可以取出，但是不能生产 public synchronized void set(String title,String content) { if(this.flag == false) {//已经生产过了，不能生产 try { super.wait();//等待 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } this.title = title; try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } this.content = content ; this.flag = false; //已经生产完成，修改标志位 super.notify(); } public synchronized void get() { if(this.flag == true){//未生产，不能取走 try { super.wait();//等待 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(this.title+&quot;&gt;&gt;&gt;&quot;+this.content); this.flag = true;//已经取出，可以生产 super.notify();//唤醒等待 }}","categories":[],"tags":[{"name":"多线程知识点","slug":"多线程知识点","permalink":"http://yoursite.com/tags/多线程知识点/"}],"author":"mh"},{"title":"","slug":"JAVA类集笔记","date":"2019-08-08T06:47:21.068Z","updated":"2019-08-08T10:30:59.222Z","comments":true,"path":"2019/08/08/JAVA类集笔记/","link":"","permalink":"http://yoursite.com/2019/08/08/JAVA类集笔记/","excerpt":"","text":"title: java类集笔记一、Collection接口（单值保存的最大父接口）Collection接口一共有15个方法，其中最常见的是add():数据增加、iterator()：为Iterator接口实例化、size():取得集合的个数;1、collection中两个常用子接口：（1）List:允许重复的子接口（2）Set:不允许的重复子接口（1）List扩充的的方法:public E get(int index):取得指定索引上的位置；public E set(int index,E element):修改指定索引位置上的数据；public ListIterator listIterator()为ListIterator接口实例化；以上3个方法只对List接口起作用，List接口的常用子类：ArrayList,Vector(不常用);例子：ArrayListpublic class Genericity { public static void main(String[] args) { // TODO Auto-generated method stub List all = new ArrayList(); all.add(“Mh”); all.add(“销售”); all.add(“李妮”); System.out.println(all.size()); Iterator iterator = all.iterator();//为Iterator实例化 while(iterator.hasNext()) {//Iterator 迭代集合输出 String s = iterator.next(); System.out.print(s+”、”); }// for(int x=0;x&lt;all.size();x++) {//循环输出集合内容// System.out.println(all.get(x)+”、”);// } }}例子：Vectorpublic static void main(String[] args) { // TODO Auto-generated method stub List all = new Vector(); all.add(“Mh”); all.add(“销售”); all.add(“李妮”); System.out.println(all.size()); Iterator iterator = all.iterator();//为Iterator实例化 while(iterator.hasNext()) {//Iterator 迭代集合输出 String s = iterator.next(); System.out.print(s+”、”); }// for(int x=0;x&lt;all.size();x++) {//循环输出集合内容// System.out.println(all.get(x)+”、”);// } }以上两个子类就结果而言没有什么不同，主要区别是：ArrayList采用异步处理方式，性能更高，属于非线性安全，输出方式有：Iterator,ListIterator,foreach。推出时间为JDK1.2;而Vector采用同步处理方式，性能相对较低，属于线程安全，输出方式：Iterator,ListIterator,foreach,Enumeration。推出时间为JDK1.0；(2)、Set子接口中常用的两个子类为HashSet和TreeSet例子：散列存放的子类：HashSet(无序)，如果内容有重复的将只会保存一个值。 public static void main(String[] args) { // TODO Auto-generated method stub Set all = new HashSet(); all.add(“Fi”); all.add(“Ai”); all.add(“Ei”); all.add(“Fi”);//内容重复 all.add(“Bi”); all.add(“Ci”); System.out.println(all.size());// Iterator iterator = all.iterator();//为Iterator实例化// while(iterator.hasNext()) {//Iterator 迭代集合输出// String s = iterator.next();// System.out.print(s+”、”);// } System.out.println(all+”、”);//因为Set子接口并没有对collection接口方法进行扩充 }}输出结果：5；[Fi, Ei, Ci, Bi, Ai]例子：排序存放的子类：TreeSet(有序)public static void main(String[] args) { // TODO Auto-generated method stub Set all = new TreeSet(); all.add(“Fi”); all.add(“Ai”); all.add(“Ei”); all.add(“Fi”);//内容重复 all.add(“Bi”); all.add(“Ci”); System.out.println(all.size()); System.out.println(all+”、”); }输出结果：5；[Ai, Bi, Ci, Ei, Fi]、 对于之前的测试都是String对象，如果要想正确排序一个自定义的对象，对于TreeSet必须实现Comparable接口，设置比较规则。对于Comparable是按序排列，对于重复元素，通过compareTo()方法返回结果是够为0来判断，为0就表示重复，不进行保存。例子：class Person implements Comparable { private String name; private int age; public Person(String name,int age) { // TODO Auto-generated constructor stub this.name = name ; this.age = age ; } @Override public String toString() { // TODO Auto-generated method stub return “姓名：”+this.name+”年龄：”+this.age; } @Override public int compareTo(Person o) {//比较大小 // TODO Auto-generated method stub if(this.age &gt; o.age) { return 1; } if(this.age &lt; o.age) { return -1; } return 0; }}public class Genericity { public static void main(String[] args) { // TODO Auto-generated method stub Set all = new TreeSet();//实例化set集合对象 all.add(new Person(“棉棉”,20)); all.add(new Person(“麻棉”,19)); all.add(new Person(“纯棉”,22)); all.add(new Person(“铁棉”,20)); System.out.println(all.size()); System.out.println(all+”、”); }}输出结果：3；[姓名：麻棉年龄：19, 姓名：棉棉年龄：20, 姓名：纯棉年龄：22]、 关于重复元素的说明：TreeSet可以依靠Comparable进行重复元素判断，而对于HashSet子类，所有的重复元素依赖于Object类的两个方法：hash码：public int hashCode()、对象比较：public boolean equals(Object obj)，一般来讲这两个方法由编程软件自动生成;对于Comparable只有排序的时候才依赖于它。二、集合输出的操作1、迭代输出：Iterator(核心)方法：public boolean hasNext() 判断是否有下一个值；public E next():取得当前元素;public void remove():移除当前元素例子：使用Iterator输出集合数据：public static void main(String[] args) { // TODO Auto-generated method stub List all = new Vector(); all.add(“Mh”); all.add(“销售”); all.add(“李妮”); System.out.println(all.size()); Iterator iterator = all.iterator();//为Iterator实例化 while(iterator.hasNext()) {//Iterator 迭代集合输出 String s = iterator.next(); System.out.print(s+”、”); }2、双向迭代输出：ListIterator(实现由前向后和由后向前输出)，此接口为Iterator的子接口方法：public void hasPrevious():判断是否有前一个元素；public E previous():取出前一个元素例子：public static void main(String[] args) { // TODO Auto-generated method stub List all = new ArrayList();//实例化set集合对象 all.add(new Person(“棉棉”,20)); all.add(new Person(“麻棉”,19)); all.add(new Person(“纯棉”,22)); all.add(new Person(“啥都棉”,20)); System.out.println(all.size()); System.out.println(all+”、”); ListIterator iter = all.listIterator(); System.out.println(“由前向后输出：”); while(iter.hasNext()) { System.out.println(iter.next()+”、”); } System.out.println(“由后向前输出：”); while(iter.hasPrevious()) { System.out.println(iter.previous()); } }}输出结果：4[姓名：棉棉年龄：20, 姓名：麻棉年龄：19, 姓名：纯棉年龄：22, 姓名：啥都棉年龄：20]、由前向后输出：姓名：棉棉年龄：20、姓名：麻棉年龄：19、姓名：纯棉年龄：22、姓名：啥都棉年龄：20、由后向前输出：姓名：啥都棉年龄：20姓名：纯棉年龄：22三、偶对象保存：Map接口，偶对象指的是一对对象，及两个对象要同时保存Map接口操作的主要方法：public V put(K key,V value):向集合中保存数据；public V get(Object key):通过指定的key取得对应的value；public Set keySet():将集合中的所有key以Set集合的方式返回；public Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet():将Map集合变为Set集合；在Map接口中常见的两个子类：HashMap,HashTable。1、HashMap(是Map接口中使用最多的一个子类)：public static void main(String[] args) { // TODO Auto-generated method stub Map&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;();//实例化Map接口 map.put(1,”张三”);//保存数据 map.put(4,”网二”); map.put(2,”麻子”); map.put(3,”李四”); System.out.println(map.get(1)); Set set = map.keySet();//将Map集合中的元素以Set集合的方式返回 Iterator i = set.iterator(); while(i.hasNext()) { Integer key = i.next(); System.out.println(key+”&gt;&gt;”+map.get(key)); } }}输出结果：张三1&gt;&gt;张三2&gt;&gt;麻子3&gt;&gt;李四4&gt;&gt;网二2、Hashtable:与HashMap无多大差别，把以上代码中的HashMap换成Hashtable即可。主要区别：HashMap的性能采用异步处理方式，性能更高，安全性属于非线性安全；能设置空值，及允许将key或value设置为null。Hashtable的性能采用同步处理方式，性能相对较低；安全性属于线性安全，不允许出现null，否则出现空指针异常。3、关于Map集合的输出问题，要想实现Map接口通过Iterator输出，那么首先需要观察Map.Entry接口。此接口的两个常用方法：取得当前的key:public K getKey();取得当前的value：public V getValue()例子： public static void main(String[] args) { // TODO Auto-generated method stub Map&lt;Integer,String&gt; map = new Hashtable&lt;Integer,String&gt;();//实例化Map接口 map.put(1,”张三”);//保存数据 map.put(4,”网二”); map.put(2,”麻子”); map.put(3,”李四”); map.put(3,”李小”); System.out.println(map.get(1)); Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();//将Map集合中的数据变为Set集合 Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; i = set.iterator(); while(i.hasNext()) { Map.Entry&lt;Integer, String&gt; me = i.next(); System.out.println(me.getKey()+”&gt;&gt;”+me.getValue()); } }}四、类集的转换如将List集合变为Set集合，而后再将这个Set集合中的全部数据保存在Map集合的value里面，而Map集合中所需要的key值用UUID生成，最后将Map中的数据进行迭代输出。例子：public static void main(String[] args) { // TODO Auto-generated method stub List list = new ArrayList&lt;&gt;(); list.add(“章程”); list.add(“舒适”); list.add(“深度”); list.add(“山东海化”); Set set = new HashSet(); set.addAll(list);//将List集合加到Set中 Map&lt;UUID,String&gt; map = new HashMap&lt;&gt;(); Iterator iter = set.iterator(); while(iter.hasNext()) { map.put(UUID.randomUUID(), iter.next());//将数据保存到Map集合中 } Iterator&lt;Map.Entry&lt;UUID,String&gt;&gt; iMap = map.entrySet().iterator(); while(iMap.hasNext()) { Map.Entry&lt;UUID, String&gt; me = iMap.next(); System.out.println(me.getKey()+”&gt;&gt;”+me.getValue()); } }输出结果：b49bf792-2fc9-4851-bf0f-cea485608c3c&gt;&gt;章程cdb48ae0-11af-4d17-8057-17628581574f&gt;&gt;深度661427a6-01ba-4f75-b58e-827872f6faf4&gt;&gt;舒适cc954ed2-bae9-4877-a064-b60c040cb090&gt;&gt;山东海化(UUID是通用唯一识别码，可以生成一个唯一的不会重复的字符串)5、关于Map中保存Key,如果不想用系统类作为Map的Key,这是就需要自定义的类作为Key出现，而且还要覆写Object类的两个方法：hashCode（）和equals()；例子：class Person { private String name; private int age; public Person(String name) { // TODO Auto-generated constructor stub this.name = name ; } @Override public String toString() { // TODO Auto-generated method stub return &quot;姓名：&quot;+this.name+&quot;年龄：&quot;+this.age; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; }}public class Genericity { public static void main(String[] args) { // TODO Auto-generated method stub Map&lt;Person,String&gt; map = new HashMap&lt;&gt;(); map.put(new Person(“张三”), new String(“zs”)); System.out.println(map.get(new Person(“张三”))); }}输出结果：zs Map注重于查找，Collection注重于输出，但是很多时Map依然会担负起输出的工作","categories":[],"tags":[]},{"title":"我的第一篇博客文章-Mh","slug":"随堂笔记","date":"2019-08-02T02:33:22.000Z","updated":"2019-08-02T03:32:11.619Z","comments":true,"path":"2019/08/02/随堂笔记/","link":"","permalink":"http://yoursite.com/2019/08/02/随堂笔记/","excerpt":"","text":"关于继承性的知识点：1、继承性：扩充类的已有功能： 如果想实现继承可通过extends关键字完成，继承的子类也称为派生类，而父类也称为超类 在Java之中一个字类只允许继承一个父类，即：不允许多重继承，但是允许多层继承； 在子类对象实例化之前，会默认调用父类之中的无参构造方法，之后再调用子类自己的构造方法，也可以通过super（）改变指定构造方法的调用； 子类继承父类的时候会将父类之中的全部操作继承下来，但是对于所有的私有属于隐式继承，而所有的非私有操作属于显示继承。2、方法的覆写：override 子类继承父类的时候，如果定义了和父类方法名称相同，参数的类型及个数相同、返回值相同的方法时，被称为方法的覆写： 在进行方法覆写时，被覆写的方法，不能拥有比父类更严格的访问控制权限，只要是方法首先想到定义就是public3、final关键字：定义不能被继承的类，不能被覆写的方法、常量，使用public static final定义的全局常量；4、单例设计模式（Singleton）：构造方法私有化，之后通过类的static方法取得本类的实例化对象，单例设计的最大特点：不管如何操作只会有本类的一个实例化对象；5、多态性：在一个范围类的任意改变 方法的多态性：方法的重载（同一个方法名称，根据参数的类型几及个数不同，可以完成不同的操作）；方法的覆写（不同的子类，针对于同一个方法可以有不同的实现）； 对象的多态性：父子类对象之间的转换操作： 对象的向上转型和对象的向下转型，可以通过instance来判断一个对象是否指定类的实例；6、抽象类：是一个半成品，规定了子类必须覆写的操作； 如果一个类之中包含了抽象方法，那么就称为抽象方法，抽象方法使用abstract关键字进行定义，而抽象类也使用abstract关键字； 抽象类就是比普通类多了抽象方法，其他的所有定义都和普通类一样，但是对于抽象类的构造方法，不能直接使用，只能通过实例化子类对象，由子类对象： 抽象类在使用的时候必须有子类，而且子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法； 抽象类的对象实例化可以靠子类的向上转型完成，这个时候所调用的抽象方法一定是杯子类所覆写过的方法；7、接口：接口属于一个特殊的类 如果一个类之中全部由抽象方法和全局常量所组成的话，那么这个特殊的类就称为接口，接口使用interface关键字进行定义； 接口也必须有子类，子类通过implements关键字实现接口，并且一个子类可以实现多个接口，每一个接口的子类都要求覆写接口之中的抽象方法； 一如果一个子类既要继承抽象类又要实现接口的话，则应该先继承后实现； 接口可以通过子类采用对象的向上转型操作进行接口对象的实例化操作； 一个接口可以同时继承多个父接口（接口的多继承） 接口之中的方法全是public； 接口的最大优点：避免了抽象类单继承的局限，所以设计的时候优先考虑接口，而不是抽象类。","categories":[],"tags":[{"name":"基于hexo的个人博客搭建","slug":"基于hexo的个人博客搭建","permalink":"http://yoursite.com/tags/基于hexo的个人博客搭建/"}],"author":"mh"},{"title":"","slug":"学习java基础过程的知识点","date":"2019-08-02T01:56:04.209Z","updated":"2019-08-13T07:31:51.439Z","comments":true,"path":"2019/08/02/学习java基础过程的知识点/","link":"","permalink":"http://yoursite.com/2019/08/02/学习java基础过程的知识点/","excerpt":"","text":"title: java基础知识点tags: 学习java基础过程的知识点 author: mhjavaSE的四大核心知识点：面向对象、类集框架、JavaIO，JDBC 一、关于单例模式的基本语法 单例模式只能有一个实例化对象，并且是属于私有化构造方法。存在一个static方法，以便获取本类的实例化对象。代码范例如： class Singleton{ private final static Singleton singleton = new Singleton(); private Singleton(){//私有化构造方法 } public void print(){ System.out.println(&quot;Hello&quot;) } public static Singleton getInfo(){//取得本类对象 return sigleton; } } public class Demo{ public static void main(String args[]){ Singleton s = null; s = Singleton.getInfo();//利用&quot;类.static方法（）&quot;取得实例化对象 s.print(); } }","categories":[],"tags":[]},{"title":"我的第一篇博客文章-Mh","slug":"我的第一篇博客文章","date":"2019-07-31T15:26:22.000Z","updated":"2019-08-13T07:31:39.812Z","comments":true,"path":"2019/07/31/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/07/31/我的第一篇博客文章/","excerpt":"","text":"##:第一章 关于hexo推送到GitHub的个人博客网站的搭建 1、准备工作：下载安装好Git,NodeJs。关于这两软件的详细介绍可看廖雪峰老师的文章。 地址：https://www.liaoxuefeng.com/wiki/896043488029600 2.进入cmd命令开始搭建： （1）、输入node -v 检查nodejs是否安装成功。（2）、利用npm安装一个cnpm淘宝的一个源，这样比较快。将指向淘宝镜像源：命令为：nmp install -g cnpm --registry-https://registry.nopm.taobao.org (3)用cnmp来安装hexo博客：cnmp install -g hexo-cli成功后可用hexo -v检查 (4）找好一个盘符为即将搭建的博客建一个新的文件夹：例如我在D:myblog（我在D盘建了一个myblog的文件夹）输入命令：d：，mkdir myblog。 (5)进入myblog目录下：cd myblog，然后用hexo生成自己的博客，输入命令：hexo init(初始化一个博客) (6)启动博客，在myblog目录下输入命令：hexo start（s）,即可在https://localhost:4000访问。括号里代表输入简写也可以 (7)新建一篇文章，按Ctrl+C断掉启动，新建一篇叫我的第一篇博客文章,输入:hexo new (n) \"我的第一篇博客文章\"。可用vim编辑器编辑文章内容，也可下载一个软件名为Visual studio code 的软件在里面编辑。下载地址为：https://code.visualstudio.com/ ![](/images/55.jpg) 插入文章内容图片等可参考：https://faceghost.com/article/396091 (8)在myblog目录下重新生成，先清理一下原先的文件。输入命令：hexo clean,再生成：hexo g,然后启动，hexo s。 接下来在输入本地：http://localhost:4000即可查看。 3、接下来讲个人博客部署到GitHub的仓库中去，首先你要注册登录GitHub的账号，要有自己的账号。可以直接去网上查查看GitHub的教程，也可借鉴一下https://www.jianshu.com/p/68b9e463333f这里面的内容。 （1）、在GitHub中新建一个仓库，输入正确的命令一定是你的（GitHub账号名.github.io) ![tip](/images/66.png) （2）、创建完成后回到myblog目录下输入命令，安装一个git部署的插件：cnpm install --save hexo-deployer-git （3）、设置关键文件，打开_config.yml，在此文件里面的最后加上：注意：type：,repo：,branch：后要跟空格。 type: git repo: 直接是你GitHub的仓库地址例如（https://github.com/mhaiwyl/mhaiwyl.github.io.git） branch: master ![tip](/images/99.png) 保存退出后，在myblog目录下输入命令：hexo d 。即可将本地博客文章推送到GitHub的仓库上。可能在最后一步时会报很多错，网上也有很多hexo的解决办法。对于我部署时报的错，一个是在写type：，repo:，branch：后忘加空格，还有一个就是输入hexo d,出现这种情况 ![tip](/images/77.png) 此时输入这两条命令：git config –-global user.email “you@example.com” git config –-global user.name “Your Name” 即可,然后重新输入hexo d 此时刷新GitHub你新建仓库的地方。就会出现类似这种 ![tip](/images/88.png) 然后在网址中输入：https：//你GitHub的名字.github.io成功显示页面就搭建成功啦。 4、更新hexo的主题 例如可以搜索：https://github.com/litten/hexo-theme-yilia(这位写感觉比较好，大家可以参考借鉴) (1)、下载主题：输入命令： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia (2)、现在去修改_config.yml文件，将里面 改成 theme:yilia即可 ![tip](/images/00.png) (3)重新清理，hexo clean ,重新生成：hexo g,重新启动：hexo s。最后输入：hexo d。就完成了 总结：初次搭建可能会遇到一些问题，在环境搭建好后，可以去网上查查hexo的常用命令，初始化博客，部署到GitHub上。本文借鉴了:codeshep.cn程序羊的B站教学视频，大家有兴趣可以加这个前辈的博客或者微信公众号：博客为：www.codesheep.cn 微信公众号：CodeSheep · 程序羊","categories":[],"tags":[{"name":"基于hexo的个人博客搭建","slug":"基于hexo的个人博客搭建","permalink":"http://yoursite.com/tags/基于hexo的个人博客搭建/"}],"author":"mh"},{"title":"Hello World","slug":"hello-world","date":"2019-07-31T15:17:25.364Z","updated":"2019-07-31T15:17:25.365Z","comments":true,"path":"2019/07/31/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}